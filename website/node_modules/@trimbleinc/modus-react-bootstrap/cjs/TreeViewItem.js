"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
var _classnames = _interopRequireDefault(require("classnames"));
var _TreeViewContext = _interopRequireDefault(require("./TreeViewContext"));
var _TreeViewItemContext = _interopRequireDefault(require("./TreeViewItemContext"));
var _TreeViewItemStyled = require("./TreeViewItemStyled");
var _useTreeViewDescendants = _interopRequireDefault(require("./useTreeViewDescendants"));
var _IndeterminateCheckbox = _interopRequireDefault(require("./IndeterminateCheckbox"));
var _jsxRuntime = require("react/jsx-runtime");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/*!
  Modus React Bootstrap 
  A React-based component library developed as a common, open source platform for all of Trimbleâ€™s web applications built on React.
  Extends React-Bootstrap v1.6.5
  Copyright (c) 2022 Trimble Inc.
 */

function getAllNodeIds(array) {
  if (!array) return [];
  return array.reduce((r, {
    id,
    children
  }) => {
    r.push(id, ...getAllNodeIds(children));
    return r;
  }, []);
}
function noop() {
  // do nothing
}
const ContentWrapper = ({
  className,
  children,
  ...props
}) => /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
  className: (0, _classnames.default)('d-flex align-items-center', className),
  ...props,
  children: children
});
const TreeViewItem = /*#__PURE__*/_react.default.forwardRef(({
  className,
  children,
  nodeId,
  label,
  collapseIcon,
  expandIcon,
  itemIcon,
  dragIcon,
  disabled,
  ...rest
}, ref) => {
  const treeViewContext = (0, _react.useContext)(_TreeViewContext.default);
  const {
    id: rootId,
    size,
    registerNode,
    unRegisterNode,
    isExpanded,
    isNodeInFocus,
    isNodeSelected,
    isCheckBoxSelected,
    toggleExpansion,
    toggleNodeSelection,
    toggleSingleCheckBoxSelection,
    toggleMultiCheckBoxSelection,
    focusNode,
    onKeyPress,
    isIndeterminate,
    checkBoxSelection,
    multiSelectCheckBox,
    collapseIcon: defaultCollapseIcon,
    expandIcon: defaultExpandIcon,
    itemIcon: defaultItemIcon,
    dragIcon: defaultDragIcon
  } = treeViewContext || {};
  const defaultRef = _react.default.useRef(null);
  const resolvedRef = ref || defaultRef;

  // Used while navigating through keyboard interactions to decide whether to trigger focus on the tree item or not
  // value will be null until a focus event occurs
  const focusSource = (0, _react.useRef)(null);

  // Used by descendant context to find the index of repositioned elements
  const [treeItemElement, setTreeItemElement] = (0, _react.useState)(null);
  const expandable = Boolean(Array.isArray(children) ? children.length : children);
  const expanded = isExpanded ? isExpanded(nodeId) : false;
  const nodeSelected = isNodeSelected ? isNodeSelected(nodeId) : false;
  const checkBoxSelected = isCheckBoxSelected ? isCheckBoxSelected(nodeId) : false;
  const checkBoxIndeterminate = checkBoxSelection && expandable && isIndeterminate ? isIndeterminate(nodeId) : false;
  const inFocus = isNodeInFocus && isNodeInFocus(nodeId);
  const finalExpandIcon = expandIcon || defaultExpandIcon || /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
    className: "modus-icons",
    children: "chevron_down_thick"
  });
  const finalCollapseIcon = collapseIcon || defaultCollapseIcon || /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
    className: "modus-icons",
    children: "chevron_right"
  });
  const finalItemIcon = itemIcon || defaultItemIcon;
  const finalDragIcon = dragIcon || defaultDragIcon;
  const blankIcon = /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
    className: "modus-icons",
    children: "blank"
  });
  const defaultTabIndex = disabled ? -1 : 0;
  const ariaLabel = rest['aria-label'] || 'Tree Item';
  const {
    parentId,
    level,
    index,
    descendants,
    updateCheckboxSelectionOnParent,
    ...descendantContext
  } = (0, _useTreeViewDescendants.default)({
    nodeId,
    element: treeItemElement,
    hasCheckBoxSelected: isCheckBoxSelected,
    handleCheckboxSelection: toggleMultiCheckBoxSelection
  });
  const currentLevel = level !== undefined ? level : 0;
  (0, _react.useEffect)(() => {
    if (registerNode) registerNode({
      id: nodeId,
      parentId,
      label,
      disabled,
      index
    });
    return () => {
      if (unRegisterNode) unRegisterNode(nodeId);
    };
  }, [registerNode, unRegisterNode, nodeId, parentId, label, disabled, index]);

  // This effect is used for focussing the tree item element while using keyboard interactions like arrow up/down key
  (0, _react.useEffect)(() => {
    const ele = resolvedRef.current;
    if (inFocus && !focusSource.current && ele) {
      ele.firstChild.focus();
    }
  }, [inFocus, resolvedRef]);
  (0, _react.useEffect)(() => {
    if (resolvedRef.current) setTreeItemElement(resolvedRef.current);
  }, [resolvedRef]);
  const showIndicator = (0, _react.useMemo)(() => {
    if (!isNodeSelected) return false;
    if (isNodeSelected(nodeId)) return true;
    return !expanded && descendants && getAllNodeIds(descendants).find(d => isNodeSelected(d));
  }, [descendants, isNodeSelected, nodeId, expanded]);
  const handleNodeSelection = _react.default.useCallback(e => {
    if (toggleNodeSelection) toggleNodeSelection(e, nodeId);
  }, [toggleNodeSelection, nodeId]);
  const handleCheckBoxSelection = _react.default.useCallback(e => {
    e.stopPropagation();
    if (multiSelectCheckBox) {
      const all = [...getAllNodeIds(descendants), nodeId];
      let checked = [];
      let unchecked = [];

      // toggle checkbox selection on children
      if (isCheckBoxSelected && isCheckBoxSelected(nodeId)) unchecked = all;else checked = all;

      // if parent is not a root node update checkbox selection state at the parent node
      if (updateCheckboxSelectionOnParent) updateCheckboxSelectionOnParent(e, nodeId, checked, unchecked);else if (toggleMultiCheckBoxSelection) toggleMultiCheckBoxSelection(e, checked, unchecked);
    } else if (toggleSingleCheckBoxSelection) toggleSingleCheckBoxSelection(e, nodeId);
  }, [descendants, multiSelectCheckBox, isCheckBoxSelected, toggleSingleCheckBoxSelection, toggleMultiCheckBoxSelection, updateCheckboxSelectionOnParent, nodeId]);
  const handleExpansion = _react.default.useCallback(e => {
    e.stopPropagation();
    if (toggleExpansion) toggleExpansion(e, nodeId);
  }, [toggleExpansion, nodeId]);
  const handleFocus = _react.default.useCallback(e => {
    // do not update focus state if it is in a disabled state or if already in focus
    if (disabled || inFocus) return;
    focusSource.current = e.target;
    if (focusNode) focusNode(nodeId);
    e.preventDefault();
  }, [disabled, inFocus, focusNode, nodeId]);
  const handleBlur = _react.default.useCallback(() => {
    focusSource.current = null;
  }, []);
  const stopPropagation = _react.default.useCallback((e, flag) => flag && e.stopPropagation(), []);
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("li", {
    className: (0, _classnames.default)('mrb-tree-view-item d-flex flex-column', showIndicator && 'selected-indicator', className),
    ref: resolvedRef,
    role: "treeitem",
    "aria-expanded": expandable ? expanded : undefined,
    "aria-selected": nodeSelected,
    "aria-disabled": disabled,
    "aria-level": currentLevel,
    "aria-label": ariaLabel,
    ...rest,
    children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)(_TreeViewItemStyled.TreeViewItemStyled, {
      level: currentLevel,
      hasCheckBoxSelection: checkBoxSelection ? 'true' : 'false',
      hasItemIcon: finalItemIcon ? 'true' : 'false',
      className: (0, _classnames.default)('list-group-item list-item-leftright-control w-100', nodeSelected && 'active', disabled && 'disabled', className),
      tabIndex: defaultTabIndex,
      onFocus: handleFocus,
      onBlur: handleBlur,
      onKeyDown: e => {
        if (e.target === e.currentTarget && onKeyPress && toggleNodeSelection) onKeyPress(e, () => toggleNodeSelection(e, nodeId));
      },
      onClick: handleNodeSelection,
      style: {
        marginTop: '-1px',
        marginBottom: '-1px'
      },
      children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)(ContentWrapper, {
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          className: "d-inline-flex",
          tabIndex: finalDragIcon ? defaultTabIndex : -1,
          onClick: e => stopPropagation(e, !!finalDragIcon),
          role: "button",
          "aria-label": "Drag the item",
          "aria-hidden": !finalDragIcon,
          children: finalDragIcon || blankIcon
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          className: "d-inline-flex item-indent h-100 align-items-center",
          tabIndex: expandable ? defaultTabIndex : -1,
          onKeyDown: e => {
            if (onKeyPress && toggleExpansion) onKeyPress(e, () => toggleExpansion(e, nodeId));
          },
          onClick: expandable ? handleExpansion : noop,
          onFocus: noop // to retain focus
          ,
          role: "button",
          "aria-label": "Expand/Collapse",
          "aria-hidden": !expandable,
          children: expandable ? expanded && finalExpandIcon || finalCollapseIcon : blankIcon
        })]
      }), checkBoxSelection && /*#__PURE__*/(0, _jsxRuntime.jsx)(ContentWrapper, {
        onClick: e => stopPropagation(e, true),
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_IndeterminateCheckbox.default, {
          "aria-label": `${checkBoxSelected ? 'Select' : 'Unselect'} ${ariaLabel}`,
          checked: checkBoxSelected,
          id: `${rootId}_cbselection_${nodeId}`,
          indeterminate: checkBoxIndeterminate,
          tabIndex: defaultTabIndex,
          onKeyDown: e => {
            if (e.key !== ' ' && onKeyPress) onKeyPress(e, () => handleCheckBoxSelection(e));
          },
          onChange: handleCheckBoxSelection,
          onFocus: noop // to retain focus
          ,
          size: size
        })
      }), finalItemIcon && /*#__PURE__*/(0, _jsxRuntime.jsx)(ContentWrapper, {
        tabIndex: defaultTabIndex,
        onClick: e => stopPropagation(e, true),
        children: finalItemIcon
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)(ContentWrapper, {
        role: "heading",
        "aria-level": currentLevel,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          role: "button",
          className: "w-100",
          children: label
        })
      })]
    }), children && /*#__PURE__*/(0, _jsxRuntime.jsx)(_TreeViewItemContext.default.Provider, {
      value: {
        level: currentLevel + 1,
        parentId: nodeId,
        ...descendantContext
      },
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)("ul", {
        role: "tree",
        className: (0, _classnames.default)('list-group w-100 h-100', !expanded && 'd-none'),
        style: {
          marginTop: '-1px',
          marginBottom: '-1px'
        },
        children: children
      })
    })]
  });
});
TreeViewItem.displayName = 'TreeViewItem';
var _default = TreeViewItem;
exports.default = _default;
module.exports = exports.default;
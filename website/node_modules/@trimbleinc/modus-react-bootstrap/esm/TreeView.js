/*!
  Modus React Bootstrap 
  A React-based component library developed as a common, open source platform for all of Trimbleâ€™s web applications built on React.
  Extends React-Bootstrap v1.6.5
  Copyright (c) 2022 Trimble Inc.
 */

import React, { useRef, useCallback, useState, useEffect } from 'react';
import classNames from 'classnames';
import TreeViewContext from './TreeViewContext';
import TreeViewItemContext from './TreeViewItemContext';
import useCustomState from './useCustomState';
import useTreeViewDescendants from './useTreeViewDescendants';
import { jsx as _jsx } from "react/jsx-runtime";
function getChildrenIds(array, nodeIdVal, recursive = true) {
  return array.reduce((r, {
    id: idVal,
    parentId
  }) => {
    if (parentId === nodeIdVal) {
      r.push(idVal, ...(recursive ? getChildrenIds(array, idVal) : []));
    }
    return r;
  }, []);
}
const TreeView = /*#__PURE__*/React.forwardRef(({
  id,
  nodeId,
  size,
  collapseIcon,
  expandIcon,
  itemIcon,
  dragIcon,
  onNodeToggle,
  onNodeSelect,
  onCheckBoxSelect,
  checkBoxSelection,
  multiSelectNode,
  multiSelectCheckBox,
  defaultExpanded,
  defaultSelected,
  expanded,
  className,
  children,
  ...props
}, ref) => {
  const nodes = useRef({});
  const defaultRef = React.useRef(null);
  const resolvedRef = ref || defaultRef;
  const [focusNodeId, setFocusNodeId] = useState();
  const [nodesExpanded, setNodeExpanded] = useCustomState(expanded, defaultExpanded || []);
  const [nodesSelected, setNodeSelected] = useState(defaultSelected && defaultSelected.length > 1 && !multiSelectNode ? [defaultSelected[0]] : []);
  const [nodeCheckBoxSelected, setNodeCheckBoxSelected] = useState([]);
  // Used by descendant context to find the index of repositioned elements
  const [treeItemElement, setTreeItemElement] = useState(null);
  const {
    registerDescendant,
    unRegisterDescendant,
    updateDescendant
  } = useTreeViewDescendants({
    nodeId,
    element: treeItemElement
  });
  useEffect(() => {
    if (resolvedRef.current) setTreeItemElement(resolvedRef.current);
  }, [resolvedRef]);

  // Helpers
  // TODO: Replace the logic getChildrenIds(getNodesArray) to avoid performance issues if any
  function getNodesArray() {
    return Object.keys(nodes.current).map(key => nodes.current[key]);
  }
  function getImmediateChildrenIds(parentId) {
    return Object.keys(nodes.current).map(key => nodes.current[key]).filter(node => node.parentId === parentId).sort((a, b) => a.index - b.index).map(child => child.id);
  }
  function getParentIds(currNodeId) {
    let {
      parentId
    } = nodes.current[currNodeId];
    const parents = [];
    while (parentId != null) {
      parents.push(parentId);
      parentId = nodes.current[parentId].parentId;
    }
    return parents;
  }

  // Handlers
  const handleMultipleSelect = useCallback((value, prevState, recursive = false) => {
    let newSelected = [];
    const oldSelected = prevState || [];
    if (recursive) {
      const array = getNodesArray();
      const childNodes = getChildrenIds(array, value);
      // unselect parents and children
      if (oldSelected.indexOf(value) !== -1) {
        const parents = getParentIds(value);
        const filtered = oldSelected.filter(i => childNodes.indexOf(i) < 0 && i !== value && parents.indexOf(i) < 0);
        newSelected = filtered;
      }
      // select children and parents with all child nodes selected
      else {
        const filtered = oldSelected.filter(item => childNodes.indexOf(item) < 0);
        newSelected = filtered.concat([value], childNodes);
      }
    } else if (oldSelected.includes(value)) newSelected = oldSelected.filter(item => item !== value);else newSelected = oldSelected.concat(value);
    return newSelected;
  }, []);
  const handleSingleSelect = useCallback((value, prevState) => {
    const selection = prevState && prevState.includes(value) ? [] : [value];
    return selection;
  }, []);

  // Tree view context
  // Actions
  const registerNode = useCallback(node => {
    nodes.current[node.id] = node;
  }, []);
  const unRegisterNode = useCallback(nodeIdVal => {
    const newNodes = {
      ...nodes.current
    };
    delete newNodes[nodeIdVal];
    nodes.current = newNodes;
  }, []);
  const toggleExpansion = useCallback((event, nodeIdValue) => {
    let newExpanded = [];
    const oldExpanded = nodesExpanded || [];
    if (oldExpanded.indexOf(nodeIdValue) !== -1) {
      newExpanded = oldExpanded.filter(item => item !== nodeIdValue);
    } else {
      newExpanded = [nodeIdValue].concat(oldExpanded);
    }
    setNodeExpanded(newExpanded);
    if (onNodeToggle) {
      onNodeToggle(event, newExpanded, nodeIdValue);
    }
  }, [nodesExpanded, setNodeExpanded, onNodeToggle]);
  const toggleNodeSelection = useCallback((event, nodeIdValue) => {
    const multiple = multiSelectNode && (event.shiftKey || event.ctrlKey || event.metaKey);
    let newSelected = [];
    if (multiple) {
      newSelected = handleMultipleSelect(nodeIdValue, nodesSelected);
    } else {
      newSelected = handleSingleSelect(nodeIdValue, nodesSelected);
    }
    setNodeSelected(newSelected);
    if (onNodeSelect) onNodeSelect(event, newSelected, nodeIdValue);
  }, [nodesSelected, setNodeSelected, onNodeSelect, handleMultipleSelect, handleSingleSelect, multiSelectNode]);
  const toggleSingleCheckBoxSelection = useCallback((event, nodeIdValue) => {
    const prevState = [...nodeCheckBoxSelected];
    const newState = prevState.includes(nodeIdValue) ? [] : [nodeIdValue];
    setNodeCheckBoxSelected(newState);
    if (onCheckBoxSelect) onCheckBoxSelect(event, newState);
  }, [nodeCheckBoxSelected, setNodeCheckBoxSelected, onCheckBoxSelect]);
  const toggleMultiCheckBoxSelection = useCallback((event, selected, unselected) => {
    setNodeCheckBoxSelected(oldItems => {
      const newItems = [...oldItems.filter(node => unselected.indexOf(node) < 0), ...selected];
      if (onCheckBoxSelect) onCheckBoxSelect(event, newItems);
      return newItems;
    });
  }, [setNodeCheckBoxSelected, onCheckBoxSelect]);
  const focusNode = useCallback(nodeIdValue => {
    setFocusNodeId(nodeIdValue);
  }, [setFocusNodeId]);

  // Verifiers
  const isExpanded = useCallback(nodeIdValue => Array.isArray(nodesExpanded) ? nodesExpanded.indexOf(nodeIdValue) !== -1 : false, [nodesExpanded]);
  const isNodeSelected = useCallback(nodeIdValue => nodesSelected.indexOf(nodeIdValue) !== -1, [nodesSelected]);
  const isCheckBoxSelected = useCallback(nodeIdValue => Array.isArray(nodeCheckBoxSelected) ? nodeCheckBoxSelected.indexOf(nodeIdValue) !== -1 : nodeCheckBoxSelected === nodeIdValue, [nodeCheckBoxSelected]);
  const isIndeterminate = useCallback(nodeIdValue => {
    const childNodes = getChildrenIds(getNodesArray(), nodeIdValue);
    if (!childNodes || childNodes.length === 0) return false;
    const unSelectChildNodes = childNodes.filter(node => nodeCheckBoxSelected.indexOf(node) < 0);
    if (unSelectChildNodes.length !== childNodes.length && unSelectChildNodes.length > 0) return true;
    return false;
  }, [nodeCheckBoxSelected]);
  const isNodeInFocus = useCallback(nodeIdValue => focusNodeId === nodeIdValue, [focusNodeId]);
  const isNodeDisabled = useCallback(nodeIdValue => nodes.current[nodeIdValue] ? nodes.current[nodeIdValue].disabled : false, [nodes]);
  const getNavigableChildrenIds = useCallback(nodeIdVal => {
    let childrenIds = getImmediateChildrenIds(nodeIdVal);
    childrenIds = childrenIds.filter(node => !isNodeDisabled(node));
    return childrenIds;
  }, [isNodeDisabled]);
  const getNextNavigableNode = useCallback(nodeIdVal => {
    // If expanded get first child
    if (isExpanded(nodeIdVal) && getNavigableChildrenIds(nodeIdVal).length > 0) {
      return getNavigableChildrenIds(nodeIdVal)[0];
    }
    let node = nodes.current[nodeIdVal];
    while (node != null) {
      // Try to get next sibling
      const siblings = getNavigableChildrenIds(node.parentId);
      const nextSibling = siblings[siblings.indexOf(node.id) + 1];
      if (nextSibling) {
        return nextSibling;
      }

      // If the sibling does not exist, go up a level to the parent and try again.
      node = nodes.current[node.parentId];
    }
    return nodeIdVal;
  }, [isExpanded, getNavigableChildrenIds]);
  const getPreviousNavigableNode = useCallback(nodeIdValue => {
    const node = nodes.current[nodeIdValue];
    const siblings = getNavigableChildrenIds(node.parentId);
    const nodeIndex = siblings.indexOf(nodeIdValue);
    if (nodeIndex === 0) {
      return node.parentId || nodeIdValue;
    }
    let currentNode = siblings[nodeIndex - 1];
    while (isExpanded(currentNode) && getNavigableChildrenIds(currentNode).length > 0) {
      currentNode = getNavigableChildrenIds(currentNode).pop();
    }
    return currentNode;
  }, [isExpanded, getNavigableChildrenIds]);
  const handleKeyDown = useCallback((event, enterKeyPressAction) => {
    let flag = false;
    const key = event.key;

    // If the tree is empty there will be no focused node
    if (event.altKey || event.currentTarget !== event.target || !focusNodeId) {
      return;
    }
    switch (key) {
      case ' ':
        toggleExpansion(event, focusNodeId);
        flag = true;
        break;
      case 'Enter':
        enterKeyPressAction();
        event.stopPropagation();
        break;
      case 'ArrowDown':
        // eslint-disable-next-line no-case-declarations
        const nextNode = getNextNavigableNode(focusNodeId);
        if (multiSelectNode && event.shiftKey && isNodeSelected(focusNodeId)) {
          // deselect if going back to the selected node
          if (isNodeSelected(nextNode)) toggleNodeSelection(event, focusNodeId);else toggleNodeSelection(event, nextNode);
        }
        focusNode(nextNode);
        flag = true;
        break;
      case 'ArrowUp':
        // eslint-disable-next-line no-case-declarations
        const nodePrevious = getPreviousNavigableNode(focusNodeId);
        if (multiSelectNode && event.shiftKey && isNodeSelected(focusNodeId)) {
          // deselect if going back to the selected node
          if (isNodeSelected(nodePrevious)) toggleNodeSelection(event, focusNodeId);else toggleNodeSelection(event, nodePrevious);
        }
        focusNode(nodePrevious);
        flag = true;
        break;
      case 'ArrowRight':
        if (!isExpanded(focusNodeId)) toggleExpansion(event, focusNodeId);
        break;
      case 'ArrowLeft':
        if (isExpanded(focusNodeId)) toggleExpansion(event, focusNodeId);
        break;
      default:
    }
    if (flag) {
      event.preventDefault();
      event.stopPropagation();
    }
  }, [focusNodeId, focusNode, isExpanded, toggleExpansion, isNodeSelected, multiSelectNode, toggleNodeSelection, getNextNavigableNode, getPreviousNavigableNode]);
  return /*#__PURE__*/_jsx(TreeViewContext.Provider, {
    value: {
      id,
      size,
      registerNode,
      unRegisterNode,
      isExpanded,
      isNodeSelected,
      isCheckBoxSelected,
      isIndeterminate,
      isNodeInFocus,
      toggleExpansion,
      toggleNodeSelection,
      toggleSingleCheckBoxSelection,
      toggleMultiCheckBoxSelection,
      onKeyPress: handleKeyDown,
      focusNode,
      checkBoxSelection: checkBoxSelection || multiSelectCheckBox,
      multiSelectCheckBox,
      multiSelectNode,
      collapseIcon,
      expandIcon,
      itemIcon,
      dragIcon
    },
    children: /*#__PURE__*/_jsx(TreeViewItemContext.Provider, {
      value: {
        parentId: nodeId,
        level: 1,
        registerDescendant,
        unRegisterDescendant,
        updateDescendant
      },
      children: /*#__PURE__*/_jsx("ul", {
        id: id,
        role: "tree",
        "aria-label": props['aria-label'] || 'Content Tree',
        className: classNames('mrb-tree-view list-group', size === 'sm' ? 'list-group-condensed' : size === 'lg' && 'list-group-lg', className),
        ...props,
        ref: ref,
        children: children
      })
    })
  });
});
TreeView.displayName = 'TreeView';
export default TreeView;
{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n/**\n * de Casteljau's algorithm for drawing and splitting bezier curves.\n * Inspired by https://pomax.github.io/bezierinfo/\n *\n * @param {Number[][]} points Array of [x,y] points: [start, control1, control2, ..., end]\n *   The original segment to split.\n * @param {Number} t Where to split the curve (value between [0, 1])\n * @return {Object} An object { left, right } where left is the segment from 0..t and\n *   right is the segment from t..1.\n */\n\n\nfunction decasteljau(points, t) {\n  var left = [];\n  var right = [];\n\n  function decasteljauRecurse(points, t) {\n    if (points.length === 1) {\n      left.push(points[0]);\n      right.push(points[0]);\n    } else {\n      var newPoints = Array(points.length - 1);\n\n      for (var i = 0; i < newPoints.length; i++) {\n        if (i === 0) {\n          left.push(points[0]);\n        }\n\n        if (i === newPoints.length - 1) {\n          right.push(points[i + 1]);\n        }\n\n        newPoints[i] = [(1 - t) * points[i][0] + t * points[i + 1][0], (1 - t) * points[i][1] + t * points[i + 1][1]];\n      }\n\n      decasteljauRecurse(newPoints, t);\n    }\n  }\n\n  if (points.length) {\n    decasteljauRecurse(points, t);\n  }\n\n  return {\n    left: left,\n    right: right.reverse()\n  };\n}\n/**\n * Convert segments represented as points back into a command object\n *\n * @param {Number[][]} points Array of [x,y] points: [start, control1, control2, ..., end]\n *   Represents a segment\n * @return {Object} A command object representing the segment.\n */\n\n\nfunction pointsToCommand(points) {\n  var command = {};\n\n  if (points.length === 4) {\n    command.x2 = points[2][0];\n    command.y2 = points[2][1];\n  }\n\n  if (points.length >= 3) {\n    command.x1 = points[1][0];\n    command.y1 = points[1][1];\n  }\n\n  command.x = points[points.length - 1][0];\n  command.y = points[points.length - 1][1];\n\n  if (points.length === 4) {\n    // start, control1, control2, end\n    command.type = 'C';\n  } else if (points.length === 3) {\n    // start, control, end\n    command.type = 'Q';\n  } else {\n    // start, end\n    command.type = 'L';\n  }\n\n  return command;\n}\n/**\n * Runs de Casteljau's algorithm enough times to produce the desired number of segments.\n *\n * @param {Number[][]} points Array of [x,y] points for de Casteljau (the initial segment to split)\n * @param {Number} segmentCount Number of segments to split the original into\n * @return {Number[][][]} Array of segments\n */\n\n\nfunction splitCurveAsPoints(points, segmentCount) {\n  segmentCount = segmentCount || 2;\n  var segments = [];\n  var remainingCurve = points;\n  var tIncrement = 1 / segmentCount; // x-----x-----x-----x\n  // t=  0.33   0.66   1\n  // x-----o-----------x\n  // r=  0.33\n  //       x-----o-----x\n  // r=         0.5  (0.33 / (1 - 0.33))  === tIncrement / (1 - (tIncrement * (i - 1))\n  // x-----x-----x-----x----x\n  // t=  0.25   0.5   0.75  1\n  // x-----o----------------x\n  // r=  0.25\n  //       x-----o----------x\n  // r=         0.33  (0.25 / (1 - 0.25))\n  //             x-----o----x\n  // r=         0.5  (0.25 / (1 - 0.5))\n\n  for (var i = 0; i < segmentCount - 1; i++) {\n    var tRelative = tIncrement / (1 - tIncrement * i);\n    var split = decasteljau(remainingCurve, tRelative);\n    segments.push(split.left);\n    remainingCurve = split.right;\n  } // last segment is just to the end from the last point\n\n\n  segments.push(remainingCurve);\n  return segments;\n}\n/**\n * Convert command objects to arrays of points, run de Casteljau's algorithm on it\n * to split into to the desired number of segments.\n *\n * @param {Object} commandStart The start command object\n * @param {Object} commandEnd The end command object\n * @param {Number} segmentCount The number of segments to create\n * @return {Object[]} An array of commands representing the segments in sequence\n */\n\n\nfunction splitCurve(commandStart, commandEnd, segmentCount) {\n  var points = [[commandStart.x, commandStart.y]];\n\n  if (commandEnd.x1 != null) {\n    points.push([commandEnd.x1, commandEnd.y1]);\n  }\n\n  if (commandEnd.x2 != null) {\n    points.push([commandEnd.x2, commandEnd.y2]);\n  }\n\n  points.push([commandEnd.x, commandEnd.y]);\n  return splitCurveAsPoints(points, segmentCount).map(pointsToCommand);\n}\n\nvar commandTokenRegex = /[MLCSTQAHVZmlcstqahv]|-?[\\d.e+-]+/g;\n/**\n * List of params for each command type in a path `d` attribute\n */\n\nvar typeMap = {\n  M: ['x', 'y'],\n  L: ['x', 'y'],\n  H: ['x'],\n  V: ['y'],\n  C: ['x1', 'y1', 'x2', 'y2', 'x', 'y'],\n  S: ['x2', 'y2', 'x', 'y'],\n  Q: ['x1', 'y1', 'x', 'y'],\n  T: ['x', 'y'],\n  A: ['rx', 'ry', 'xAxisRotation', 'largeArcFlag', 'sweepFlag', 'x', 'y'],\n  Z: []\n}; // Add lower case entries too matching uppercase (e.g. 'm' == 'M')\n\nObject.keys(typeMap).forEach(function (key) {\n  typeMap[key.toLowerCase()] = typeMap[key];\n});\n\nfunction arrayOfLength(length, value) {\n  var array = Array(length);\n\n  for (var i = 0; i < length; i++) {\n    array[i] = value;\n  }\n\n  return array;\n}\n/**\n * Converts a command object to a string to be used in a `d` attribute\n * @param {Object} command A command object\n * @return {String} The string for the `d` attribute\n */\n\n\nfunction commandToString(command) {\n  return \"\".concat(command.type).concat(typeMap[command.type].map(function (p) {\n    return command[p];\n  }).join(','));\n}\n/**\n * Converts command A to have the same type as command B.\n *\n * e.g., L0,5 -> C0,5,0,5,0,5\n *\n * Uses these rules:\n * x1 <- x\n * x2 <- x\n * y1 <- y\n * y2 <- y\n * rx <- 0\n * ry <- 0\n * xAxisRotation <- read from B\n * largeArcFlag <- read from B\n * sweepflag <- read from B\n *\n * @param {Object} aCommand Command object from path `d` attribute\n * @param {Object} bCommand Command object from path `d` attribute to match against\n * @return {Object} aCommand converted to type of bCommand\n */\n\n\nfunction convertToSameType(aCommand, bCommand) {\n  var conversionMap = {\n    x1: 'x',\n    y1: 'y',\n    x2: 'x',\n    y2: 'y'\n  };\n  var readFromBKeys = ['xAxisRotation', 'largeArcFlag', 'sweepFlag']; // convert (but ignore M types)\n\n  if (aCommand.type !== bCommand.type && bCommand.type.toUpperCase() !== 'M') {\n    var aConverted = {};\n    Object.keys(bCommand).forEach(function (bKey) {\n      var bValue = bCommand[bKey]; // first read from the A command\n\n      var aValue = aCommand[bKey]; // if it is one of these values, read from B no matter what\n\n      if (aValue === undefined) {\n        if (readFromBKeys.includes(bKey)) {\n          aValue = bValue;\n        } else {\n          // if it wasn't in the A command, see if an equivalent was\n          if (aValue === undefined && conversionMap[bKey]) {\n            aValue = aCommand[conversionMap[bKey]];\n          } // if it doesn't have a converted value, use 0\n\n\n          if (aValue === undefined) {\n            aValue = 0;\n          }\n        }\n      }\n\n      aConverted[bKey] = aValue;\n    }); // update the type to match B\n\n    aConverted.type = bCommand.type;\n    aCommand = aConverted;\n  }\n\n  return aCommand;\n}\n/**\n * Interpolate between command objects commandStart and commandEnd segmentCount times.\n * If the types are L, Q, or C then the curves are split as per de Casteljau's algorithm.\n * Otherwise we just copy commandStart segmentCount - 1 times, finally ending with commandEnd.\n *\n * @param {Object} commandStart Command object at the beginning of the segment\n * @param {Object} commandEnd Command object at the end of the segment\n * @param {Number} segmentCount The number of segments to split this into. If only 1\n *   Then [commandEnd] is returned.\n * @return {Object[]} Array of ~segmentCount command objects between commandStart and\n *   commandEnd. (Can be segmentCount+1 objects if commandStart is type M).\n */\n\n\nfunction splitSegment(commandStart, commandEnd, segmentCount) {\n  var segments = []; // line, quadratic bezier, or cubic bezier\n\n  if (commandEnd.type === 'L' || commandEnd.type === 'Q' || commandEnd.type === 'C') {\n    segments = segments.concat(splitCurve(commandStart, commandEnd, segmentCount)); // general case - just copy the same point\n  } else {\n    var copyCommand = _extends({}, commandStart); // convert M to L\n\n\n    if (copyCommand.type === 'M') {\n      copyCommand.type = 'L';\n    }\n\n    segments = segments.concat(arrayOfLength(segmentCount - 1).map(function () {\n      return copyCommand;\n    }));\n    segments.push(commandEnd);\n  }\n\n  return segments;\n}\n/**\n * Extends an array of commandsToExtend to the length of the referenceCommands by\n * splitting segments until the number of commands match. Ensures all the actual\n * points of commandsToExtend are in the extended array.\n *\n * @param {Object[]} commandsToExtend The command object array to extend\n * @param {Object[]} referenceCommands The command object array to match in length\n * @param {Function} excludeSegment a function that takes a start command object and\n *   end command object and returns true if the segment should be excluded from splitting.\n * @return {Object[]} The extended commandsToExtend array\n */\n\n\nfunction extend(commandsToExtend, referenceCommands, excludeSegment) {\n  // compute insertion points:\n  // number of segments in the path to extend\n  var numSegmentsToExtend = commandsToExtend.length - 1; // number of segments in the reference path.\n\n  var numReferenceSegments = referenceCommands.length - 1; // this value is always between [0, 1].\n\n  var segmentRatio = numSegmentsToExtend / numReferenceSegments; // create a map, mapping segments in referenceCommands to how many points\n  // should be added in that segment (should always be >= 1 since we need each\n  // point itself).\n  // 0 = segment 0-1, 1 = segment 1-2, n-1 = last vertex\n\n  var countPointsPerSegment = arrayOfLength(numReferenceSegments).reduce(function (accum, d, i) {\n    var insertIndex = Math.floor(segmentRatio * i); // handle excluding segments\n\n    if (excludeSegment && insertIndex < commandsToExtend.length - 1 && excludeSegment(commandsToExtend[insertIndex], commandsToExtend[insertIndex + 1])) {\n      // set the insertIndex to the segment that this point should be added to:\n      // round the insertIndex essentially so we split half and half on\n      // neighbouring segments. hence the segmentRatio * i < 0.5\n      var addToPriorSegment = segmentRatio * i % 1 < 0.5; // only skip segment if we already have 1 point in it (can't entirely remove a segment)\n\n      if (accum[insertIndex]) {\n        // TODO - Note this is a naive algorithm that should work for most d3-area use cases\n        // but if two adjacent segments are supposed to be skipped, this will not perform as\n        // expected. Could be updated to search for nearest segment to place the point in, but\n        // will only do that if necessary.\n        // add to the prior segment\n        if (addToPriorSegment) {\n          if (insertIndex > 0) {\n            insertIndex -= 1; // not possible to add to previous so adding to next\n          } else if (insertIndex < commandsToExtend.length - 1) {\n            insertIndex += 1;\n          } // add to next segment\n\n        } else if (insertIndex < commandsToExtend.length - 1) {\n          insertIndex += 1; // not possible to add to next so adding to previous\n        } else if (insertIndex > 0) {\n          insertIndex -= 1;\n        }\n      }\n    }\n\n    accum[insertIndex] = (accum[insertIndex] || 0) + 1;\n    return accum;\n  }, []); // extend each segment to have the correct number of points for a smooth interpolation\n\n  var extended = countPointsPerSegment.reduce(function (extended, segmentCount, i) {\n    // if last command, just add `segmentCount` number of times\n    if (i === commandsToExtend.length - 1) {\n      var lastCommandCopies = arrayOfLength(segmentCount, _extends({}, commandsToExtend[commandsToExtend.length - 1])); // convert M to L\n\n      if (lastCommandCopies[0].type === 'M') {\n        lastCommandCopies.forEach(function (d) {\n          d.type = 'L';\n        });\n      }\n\n      return extended.concat(lastCommandCopies);\n    } // otherwise, split the segment segmentCount times.\n\n\n    return extended.concat(splitSegment(commandsToExtend[i], commandsToExtend[i + 1], segmentCount));\n  }, []); // add in the very first point since splitSegment only adds in the ones after it\n\n  extended.unshift(commandsToExtend[0]);\n  return extended;\n}\n/**\n * Takes a path `d` string and converts it into an array of command\n * objects. Drops the `Z` character.\n *\n * @param {String|null} d A path `d` string\n */\n\n\nfunction pathCommandsFromString(d) {\n  // split into valid tokens\n  var tokens = (d || '').match(commandTokenRegex) || [];\n  var commands = [];\n  var commandArgs;\n  var command; // iterate over each token, checking if we are at a new command\n  // by presence in the typeMap\n\n  for (var i = 0; i < tokens.length; ++i) {\n    commandArgs = typeMap[tokens[i]]; // new command found:\n\n    if (commandArgs) {\n      command = {\n        type: tokens[i]\n      }; // add each of the expected args for this command:\n\n      for (var a = 0; a < commandArgs.length; ++a) {\n        command[commandArgs[a]] = +tokens[i + a + 1];\n      } // need to increment our token index appropriately since\n      // we consumed token args\n\n\n      i += commandArgs.length;\n      commands.push(command);\n    }\n  }\n\n  return commands;\n}\n/**\n * Interpolate from A to B by extending A and B during interpolation to have\n * the same number of points. This allows for a smooth transition when they\n * have a different number of points.\n *\n * Ignores the `Z` command in paths unless both A and B end with it.\n *\n * This function works directly with arrays of command objects instead of with\n * path `d` strings (see interpolatePath for working with `d` strings).\n *\n * @param {Object[]} aCommandsInput Array of path commands\n * @param {Object[]} bCommandsInput Array of path commands\n * @param {Function} excludeSegment a function that takes a start command object and\n *   end command object and returns true if the segment should be excluded from splitting.\n * @returns {Function} Interpolation function that maps t ([0, 1]) to an array of path commands.\n */\n\n\nfunction interpolatePathCommands(aCommandsInput, bCommandsInput, excludeSegment) {\n  // make a copy so we don't mess with the input arrays\n  var aCommands = aCommandsInput == null ? [] : aCommandsInput.slice();\n  var bCommands = bCommandsInput == null ? [] : bCommandsInput.slice(); // both input sets are empty, so we don't interpolate\n\n  if (!aCommands.length && !bCommands.length) {\n    return function nullInterpolator() {\n      return [];\n    };\n  } // do we add Z during interpolation? yes if both have it. (we'd expect both to have it or not)\n\n\n  var addZ = (aCommands.length === 0 || aCommands[aCommands.length - 1].type === 'Z') && (bCommands.length === 0 || bCommands[bCommands.length - 1].type === 'Z'); // we temporarily remove Z\n\n  if (aCommands.length > 0 && aCommands[aCommands.length - 1].type === 'Z') {\n    aCommands.pop();\n  }\n\n  if (bCommands.length > 0 && bCommands[bCommands.length - 1].type === 'Z') {\n    bCommands.pop();\n  } // if A is empty, treat it as if it used to contain just the first point\n  // of B. This makes it so the line extends out of from that first point.\n\n\n  if (!aCommands.length) {\n    aCommands.push(bCommands[0]); // otherwise if B is empty, treat it as if it contains the first point\n    // of A. This makes it so the line retracts into the first point.\n  } else if (!bCommands.length) {\n    bCommands.push(aCommands[0]);\n  } // extend to match equal size\n\n\n  var numPointsToExtend = Math.abs(bCommands.length - aCommands.length);\n\n  if (numPointsToExtend !== 0) {\n    // B has more points than A, so add points to A before interpolating\n    if (bCommands.length > aCommands.length) {\n      aCommands = extend(aCommands, bCommands, excludeSegment); // else if A has more points than B, add more points to B\n    } else if (bCommands.length < aCommands.length) {\n      bCommands = extend(bCommands, aCommands, excludeSegment);\n    }\n  } // commands have same length now.\n  // convert commands in A to the same type as those in B\n\n\n  aCommands = aCommands.map(function (aCommand, i) {\n    return convertToSameType(aCommand, bCommands[i]);\n  }); // create mutable interpolated command objects\n\n  var interpolatedCommands = aCommands.map(function (aCommand) {\n    return _objectSpread2({}, aCommand);\n  });\n\n  if (addZ) {\n    interpolatedCommands.push({\n      type: 'Z'\n    });\n    aCommands.push({\n      type: 'Z'\n    }); // required for when returning at t == 0\n  }\n\n  return function pathCommandInterpolator(t) {\n    // at 1 return the final value without the extensions used during interpolation\n    if (t === 1) {\n      return bCommandsInput == null ? [] : bCommandsInput;\n    } // work with aCommands directly since interpolatedCommands are mutated\n\n\n    if (t === 0) {\n      return aCommands;\n    } // interpolate the commands using the mutable interpolated command objs\n\n\n    for (var i = 0; i < interpolatedCommands.length; ++i) {\n      // if (interpolatedCommands[i].type === 'Z') continue;\n      var aCommand = aCommands[i];\n      var bCommand = bCommands[i];\n      var interpolatedCommand = interpolatedCommands[i];\n\n      var _iterator = _createForOfIteratorHelper(typeMap[interpolatedCommand.type]),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var arg = _step.value;\n          interpolatedCommand[arg] = (1 - t) * aCommand[arg] + t * bCommand[arg]; // do not use floats for flags (#27), round to integer\n\n          if (arg === 'largeArcFlag' || arg === 'sweepFlag') {\n            interpolatedCommand[arg] = Math.round(interpolatedCommand[arg]);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    return interpolatedCommands;\n  };\n}\n/**\n * Interpolate from A to B by extending A and B during interpolation to have\n * the same number of points. This allows for a smooth transition when they\n * have a different number of points.\n *\n * Ignores the `Z` character in paths unless both A and B end with it.\n *\n * @param {String} a The `d` attribute for a path\n * @param {String} b The `d` attribute for a path\n * @param {Function} excludeSegment a function that takes a start command object and\n *   end command object and returns true if the segment should be excluded from splitting.\n * @returns {Function} Interpolation function that maps t ([0, 1]) to a path `d` string.\n */\n\n\nfunction interpolatePath(a, b, excludeSegment) {\n  var aCommands = pathCommandsFromString(a);\n  var bCommands = pathCommandsFromString(b);\n\n  if (!aCommands.length && !bCommands.length) {\n    return function nullInterpolator() {\n      return '';\n    };\n  }\n\n  var commandInterpolator = interpolatePathCommands(aCommands, bCommands, excludeSegment);\n  return function pathStringInterpolator(t) {\n    // at 1 return the final value without the extensions used during interpolation\n    if (t === 1) {\n      return b == null ? '' : b;\n    }\n\n    var interpolatedCommands = commandInterpolator(t); // convert to a string (fastest concat: https://jsperf.com/join-concat/150)\n\n    var interpolatedString = '';\n\n    var _iterator2 = _createForOfIteratorHelper(interpolatedCommands),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var interpolatedCommand = _step2.value;\n        interpolatedString += commandToString(interpolatedCommand);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return interpolatedString;\n  };\n}\n\nexport { interpolatePath, interpolatePathCommands, pathCommandsFromString };","map":{"version":3,"sources":["/Users/ssakhilesha/Documents/GitHub/Masters-BDA-project/website/covid19/node_modules/d3-interpolate-path/build/d3-interpolate-path.mjs"],"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread2","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","_extends","assign","prototype","hasOwnProperty","call","_unsupportedIterableToArray","o","minLen","_arrayLikeToArray","n","toString","slice","constructor","name","Array","from","test","arr","len","arr2","_createForOfIteratorHelper","allowArrayLike","it","Symbol","iterator","isArray","F","s","done","e","f","TypeError","normalCompletion","didErr","err","step","next","return","decasteljau","points","t","left","right","decasteljauRecurse","newPoints","reverse","pointsToCommand","command","x2","y2","x1","y1","x","y","type","splitCurveAsPoints","segmentCount","segments","remainingCurve","tIncrement","tRelative","split","splitCurve","commandStart","commandEnd","map","commandTokenRegex","typeMap","M","L","H","V","C","S","Q","T","A","Z","toLowerCase","arrayOfLength","array","commandToString","concat","p","join","convertToSameType","aCommand","bCommand","conversionMap","readFromBKeys","toUpperCase","aConverted","bKey","bValue","aValue","undefined","includes","splitSegment","copyCommand","extend","commandsToExtend","referenceCommands","excludeSegment","numSegmentsToExtend","numReferenceSegments","segmentRatio","countPointsPerSegment","reduce","accum","d","insertIndex","Math","floor","addToPriorSegment","extended","lastCommandCopies","unshift","pathCommandsFromString","tokens","match","commands","commandArgs","a","interpolatePathCommands","aCommandsInput","bCommandsInput","aCommands","bCommands","nullInterpolator","addZ","pop","numPointsToExtend","abs","interpolatedCommands","pathCommandInterpolator","interpolatedCommand","_iterator","_step","arg","round","interpolatePath","b","commandInterpolator","pathStringInterpolator","interpolatedString","_iterator2","_step2"],"mappings":"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","sourcesContent":["function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = it.call(o);\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\n/**\n * de Casteljau's algorithm for drawing and splitting bezier curves.\n * Inspired by https://pomax.github.io/bezierinfo/\n *\n * @param {Number[][]} points Array of [x,y] points: [start, control1, control2, ..., end]\n *   The original segment to split.\n * @param {Number} t Where to split the curve (value between [0, 1])\n * @return {Object} An object { left, right } where left is the segment from 0..t and\n *   right is the segment from t..1.\n */\nfunction decasteljau(points, t) {\n  var left = [];\n  var right = [];\n\n  function decasteljauRecurse(points, t) {\n    if (points.length === 1) {\n      left.push(points[0]);\n      right.push(points[0]);\n    } else {\n      var newPoints = Array(points.length - 1);\n\n      for (var i = 0; i < newPoints.length; i++) {\n        if (i === 0) {\n          left.push(points[0]);\n        }\n\n        if (i === newPoints.length - 1) {\n          right.push(points[i + 1]);\n        }\n\n        newPoints[i] = [(1 - t) * points[i][0] + t * points[i + 1][0], (1 - t) * points[i][1] + t * points[i + 1][1]];\n      }\n\n      decasteljauRecurse(newPoints, t);\n    }\n  }\n\n  if (points.length) {\n    decasteljauRecurse(points, t);\n  }\n\n  return {\n    left: left,\n    right: right.reverse()\n  };\n}\n/**\n * Convert segments represented as points back into a command object\n *\n * @param {Number[][]} points Array of [x,y] points: [start, control1, control2, ..., end]\n *   Represents a segment\n * @return {Object} A command object representing the segment.\n */\n\n\nfunction pointsToCommand(points) {\n  var command = {};\n\n  if (points.length === 4) {\n    command.x2 = points[2][0];\n    command.y2 = points[2][1];\n  }\n\n  if (points.length >= 3) {\n    command.x1 = points[1][0];\n    command.y1 = points[1][1];\n  }\n\n  command.x = points[points.length - 1][0];\n  command.y = points[points.length - 1][1];\n\n  if (points.length === 4) {\n    // start, control1, control2, end\n    command.type = 'C';\n  } else if (points.length === 3) {\n    // start, control, end\n    command.type = 'Q';\n  } else {\n    // start, end\n    command.type = 'L';\n  }\n\n  return command;\n}\n/**\n * Runs de Casteljau's algorithm enough times to produce the desired number of segments.\n *\n * @param {Number[][]} points Array of [x,y] points for de Casteljau (the initial segment to split)\n * @param {Number} segmentCount Number of segments to split the original into\n * @return {Number[][][]} Array of segments\n */\n\n\nfunction splitCurveAsPoints(points, segmentCount) {\n  segmentCount = segmentCount || 2;\n  var segments = [];\n  var remainingCurve = points;\n  var tIncrement = 1 / segmentCount; // x-----x-----x-----x\n  // t=  0.33   0.66   1\n  // x-----o-----------x\n  // r=  0.33\n  //       x-----o-----x\n  // r=         0.5  (0.33 / (1 - 0.33))  === tIncrement / (1 - (tIncrement * (i - 1))\n  // x-----x-----x-----x----x\n  // t=  0.25   0.5   0.75  1\n  // x-----o----------------x\n  // r=  0.25\n  //       x-----o----------x\n  // r=         0.33  (0.25 / (1 - 0.25))\n  //             x-----o----x\n  // r=         0.5  (0.25 / (1 - 0.5))\n\n  for (var i = 0; i < segmentCount - 1; i++) {\n    var tRelative = tIncrement / (1 - tIncrement * i);\n    var split = decasteljau(remainingCurve, tRelative);\n    segments.push(split.left);\n    remainingCurve = split.right;\n  } // last segment is just to the end from the last point\n\n\n  segments.push(remainingCurve);\n  return segments;\n}\n/**\n * Convert command objects to arrays of points, run de Casteljau's algorithm on it\n * to split into to the desired number of segments.\n *\n * @param {Object} commandStart The start command object\n * @param {Object} commandEnd The end command object\n * @param {Number} segmentCount The number of segments to create\n * @return {Object[]} An array of commands representing the segments in sequence\n */\n\n\nfunction splitCurve(commandStart, commandEnd, segmentCount) {\n  var points = [[commandStart.x, commandStart.y]];\n\n  if (commandEnd.x1 != null) {\n    points.push([commandEnd.x1, commandEnd.y1]);\n  }\n\n  if (commandEnd.x2 != null) {\n    points.push([commandEnd.x2, commandEnd.y2]);\n  }\n\n  points.push([commandEnd.x, commandEnd.y]);\n  return splitCurveAsPoints(points, segmentCount).map(pointsToCommand);\n}\n\nvar commandTokenRegex = /[MLCSTQAHVZmlcstqahv]|-?[\\d.e+-]+/g;\n/**\n * List of params for each command type in a path `d` attribute\n */\n\nvar typeMap = {\n  M: ['x', 'y'],\n  L: ['x', 'y'],\n  H: ['x'],\n  V: ['y'],\n  C: ['x1', 'y1', 'x2', 'y2', 'x', 'y'],\n  S: ['x2', 'y2', 'x', 'y'],\n  Q: ['x1', 'y1', 'x', 'y'],\n  T: ['x', 'y'],\n  A: ['rx', 'ry', 'xAxisRotation', 'largeArcFlag', 'sweepFlag', 'x', 'y'],\n  Z: []\n}; // Add lower case entries too matching uppercase (e.g. 'm' == 'M')\n\nObject.keys(typeMap).forEach(function (key) {\n  typeMap[key.toLowerCase()] = typeMap[key];\n});\n\nfunction arrayOfLength(length, value) {\n  var array = Array(length);\n\n  for (var i = 0; i < length; i++) {\n    array[i] = value;\n  }\n\n  return array;\n}\n/**\n * Converts a command object to a string to be used in a `d` attribute\n * @param {Object} command A command object\n * @return {String} The string for the `d` attribute\n */\n\n\nfunction commandToString(command) {\n  return \"\".concat(command.type).concat(typeMap[command.type].map(function (p) {\n    return command[p];\n  }).join(','));\n}\n/**\n * Converts command A to have the same type as command B.\n *\n * e.g., L0,5 -> C0,5,0,5,0,5\n *\n * Uses these rules:\n * x1 <- x\n * x2 <- x\n * y1 <- y\n * y2 <- y\n * rx <- 0\n * ry <- 0\n * xAxisRotation <- read from B\n * largeArcFlag <- read from B\n * sweepflag <- read from B\n *\n * @param {Object} aCommand Command object from path `d` attribute\n * @param {Object} bCommand Command object from path `d` attribute to match against\n * @return {Object} aCommand converted to type of bCommand\n */\n\n\nfunction convertToSameType(aCommand, bCommand) {\n  var conversionMap = {\n    x1: 'x',\n    y1: 'y',\n    x2: 'x',\n    y2: 'y'\n  };\n  var readFromBKeys = ['xAxisRotation', 'largeArcFlag', 'sweepFlag']; // convert (but ignore M types)\n\n  if (aCommand.type !== bCommand.type && bCommand.type.toUpperCase() !== 'M') {\n    var aConverted = {};\n    Object.keys(bCommand).forEach(function (bKey) {\n      var bValue = bCommand[bKey]; // first read from the A command\n\n      var aValue = aCommand[bKey]; // if it is one of these values, read from B no matter what\n\n      if (aValue === undefined) {\n        if (readFromBKeys.includes(bKey)) {\n          aValue = bValue;\n        } else {\n          // if it wasn't in the A command, see if an equivalent was\n          if (aValue === undefined && conversionMap[bKey]) {\n            aValue = aCommand[conversionMap[bKey]];\n          } // if it doesn't have a converted value, use 0\n\n\n          if (aValue === undefined) {\n            aValue = 0;\n          }\n        }\n      }\n\n      aConverted[bKey] = aValue;\n    }); // update the type to match B\n\n    aConverted.type = bCommand.type;\n    aCommand = aConverted;\n  }\n\n  return aCommand;\n}\n/**\n * Interpolate between command objects commandStart and commandEnd segmentCount times.\n * If the types are L, Q, or C then the curves are split as per de Casteljau's algorithm.\n * Otherwise we just copy commandStart segmentCount - 1 times, finally ending with commandEnd.\n *\n * @param {Object} commandStart Command object at the beginning of the segment\n * @param {Object} commandEnd Command object at the end of the segment\n * @param {Number} segmentCount The number of segments to split this into. If only 1\n *   Then [commandEnd] is returned.\n * @return {Object[]} Array of ~segmentCount command objects between commandStart and\n *   commandEnd. (Can be segmentCount+1 objects if commandStart is type M).\n */\n\n\nfunction splitSegment(commandStart, commandEnd, segmentCount) {\n  var segments = []; // line, quadratic bezier, or cubic bezier\n\n  if (commandEnd.type === 'L' || commandEnd.type === 'Q' || commandEnd.type === 'C') {\n    segments = segments.concat(splitCurve(commandStart, commandEnd, segmentCount)); // general case - just copy the same point\n  } else {\n    var copyCommand = _extends({}, commandStart); // convert M to L\n\n\n    if (copyCommand.type === 'M') {\n      copyCommand.type = 'L';\n    }\n\n    segments = segments.concat(arrayOfLength(segmentCount - 1).map(function () {\n      return copyCommand;\n    }));\n    segments.push(commandEnd);\n  }\n\n  return segments;\n}\n/**\n * Extends an array of commandsToExtend to the length of the referenceCommands by\n * splitting segments until the number of commands match. Ensures all the actual\n * points of commandsToExtend are in the extended array.\n *\n * @param {Object[]} commandsToExtend The command object array to extend\n * @param {Object[]} referenceCommands The command object array to match in length\n * @param {Function} excludeSegment a function that takes a start command object and\n *   end command object and returns true if the segment should be excluded from splitting.\n * @return {Object[]} The extended commandsToExtend array\n */\n\n\nfunction extend(commandsToExtend, referenceCommands, excludeSegment) {\n  // compute insertion points:\n  // number of segments in the path to extend\n  var numSegmentsToExtend = commandsToExtend.length - 1; // number of segments in the reference path.\n\n  var numReferenceSegments = referenceCommands.length - 1; // this value is always between [0, 1].\n\n  var segmentRatio = numSegmentsToExtend / numReferenceSegments; // create a map, mapping segments in referenceCommands to how many points\n  // should be added in that segment (should always be >= 1 since we need each\n  // point itself).\n  // 0 = segment 0-1, 1 = segment 1-2, n-1 = last vertex\n\n  var countPointsPerSegment = arrayOfLength(numReferenceSegments).reduce(function (accum, d, i) {\n    var insertIndex = Math.floor(segmentRatio * i); // handle excluding segments\n\n    if (excludeSegment && insertIndex < commandsToExtend.length - 1 && excludeSegment(commandsToExtend[insertIndex], commandsToExtend[insertIndex + 1])) {\n      // set the insertIndex to the segment that this point should be added to:\n      // round the insertIndex essentially so we split half and half on\n      // neighbouring segments. hence the segmentRatio * i < 0.5\n      var addToPriorSegment = segmentRatio * i % 1 < 0.5; // only skip segment if we already have 1 point in it (can't entirely remove a segment)\n\n      if (accum[insertIndex]) {\n        // TODO - Note this is a naive algorithm that should work for most d3-area use cases\n        // but if two adjacent segments are supposed to be skipped, this will not perform as\n        // expected. Could be updated to search for nearest segment to place the point in, but\n        // will only do that if necessary.\n        // add to the prior segment\n        if (addToPriorSegment) {\n          if (insertIndex > 0) {\n            insertIndex -= 1; // not possible to add to previous so adding to next\n          } else if (insertIndex < commandsToExtend.length - 1) {\n            insertIndex += 1;\n          } // add to next segment\n\n        } else if (insertIndex < commandsToExtend.length - 1) {\n          insertIndex += 1; // not possible to add to next so adding to previous\n        } else if (insertIndex > 0) {\n          insertIndex -= 1;\n        }\n      }\n    }\n\n    accum[insertIndex] = (accum[insertIndex] || 0) + 1;\n    return accum;\n  }, []); // extend each segment to have the correct number of points for a smooth interpolation\n\n  var extended = countPointsPerSegment.reduce(function (extended, segmentCount, i) {\n    // if last command, just add `segmentCount` number of times\n    if (i === commandsToExtend.length - 1) {\n      var lastCommandCopies = arrayOfLength(segmentCount, _extends({}, commandsToExtend[commandsToExtend.length - 1])); // convert M to L\n\n      if (lastCommandCopies[0].type === 'M') {\n        lastCommandCopies.forEach(function (d) {\n          d.type = 'L';\n        });\n      }\n\n      return extended.concat(lastCommandCopies);\n    } // otherwise, split the segment segmentCount times.\n\n\n    return extended.concat(splitSegment(commandsToExtend[i], commandsToExtend[i + 1], segmentCount));\n  }, []); // add in the very first point since splitSegment only adds in the ones after it\n\n  extended.unshift(commandsToExtend[0]);\n  return extended;\n}\n/**\n * Takes a path `d` string and converts it into an array of command\n * objects. Drops the `Z` character.\n *\n * @param {String|null} d A path `d` string\n */\n\n\nfunction pathCommandsFromString(d) {\n  // split into valid tokens\n  var tokens = (d || '').match(commandTokenRegex) || [];\n  var commands = [];\n  var commandArgs;\n  var command; // iterate over each token, checking if we are at a new command\n  // by presence in the typeMap\n\n  for (var i = 0; i < tokens.length; ++i) {\n    commandArgs = typeMap[tokens[i]]; // new command found:\n\n    if (commandArgs) {\n      command = {\n        type: tokens[i]\n      }; // add each of the expected args for this command:\n\n      for (var a = 0; a < commandArgs.length; ++a) {\n        command[commandArgs[a]] = +tokens[i + a + 1];\n      } // need to increment our token index appropriately since\n      // we consumed token args\n\n\n      i += commandArgs.length;\n      commands.push(command);\n    }\n  }\n\n  return commands;\n}\n/**\n * Interpolate from A to B by extending A and B during interpolation to have\n * the same number of points. This allows for a smooth transition when they\n * have a different number of points.\n *\n * Ignores the `Z` command in paths unless both A and B end with it.\n *\n * This function works directly with arrays of command objects instead of with\n * path `d` strings (see interpolatePath for working with `d` strings).\n *\n * @param {Object[]} aCommandsInput Array of path commands\n * @param {Object[]} bCommandsInput Array of path commands\n * @param {Function} excludeSegment a function that takes a start command object and\n *   end command object and returns true if the segment should be excluded from splitting.\n * @returns {Function} Interpolation function that maps t ([0, 1]) to an array of path commands.\n */\n\nfunction interpolatePathCommands(aCommandsInput, bCommandsInput, excludeSegment) {\n  // make a copy so we don't mess with the input arrays\n  var aCommands = aCommandsInput == null ? [] : aCommandsInput.slice();\n  var bCommands = bCommandsInput == null ? [] : bCommandsInput.slice(); // both input sets are empty, so we don't interpolate\n\n  if (!aCommands.length && !bCommands.length) {\n    return function nullInterpolator() {\n      return [];\n    };\n  } // do we add Z during interpolation? yes if both have it. (we'd expect both to have it or not)\n\n\n  var addZ = (aCommands.length === 0 || aCommands[aCommands.length - 1].type === 'Z') && (bCommands.length === 0 || bCommands[bCommands.length - 1].type === 'Z'); // we temporarily remove Z\n\n  if (aCommands.length > 0 && aCommands[aCommands.length - 1].type === 'Z') {\n    aCommands.pop();\n  }\n\n  if (bCommands.length > 0 && bCommands[bCommands.length - 1].type === 'Z') {\n    bCommands.pop();\n  } // if A is empty, treat it as if it used to contain just the first point\n  // of B. This makes it so the line extends out of from that first point.\n\n\n  if (!aCommands.length) {\n    aCommands.push(bCommands[0]); // otherwise if B is empty, treat it as if it contains the first point\n    // of A. This makes it so the line retracts into the first point.\n  } else if (!bCommands.length) {\n    bCommands.push(aCommands[0]);\n  } // extend to match equal size\n\n\n  var numPointsToExtend = Math.abs(bCommands.length - aCommands.length);\n\n  if (numPointsToExtend !== 0) {\n    // B has more points than A, so add points to A before interpolating\n    if (bCommands.length > aCommands.length) {\n      aCommands = extend(aCommands, bCommands, excludeSegment); // else if A has more points than B, add more points to B\n    } else if (bCommands.length < aCommands.length) {\n      bCommands = extend(bCommands, aCommands, excludeSegment);\n    }\n  } // commands have same length now.\n  // convert commands in A to the same type as those in B\n\n\n  aCommands = aCommands.map(function (aCommand, i) {\n    return convertToSameType(aCommand, bCommands[i]);\n  }); // create mutable interpolated command objects\n\n  var interpolatedCommands = aCommands.map(function (aCommand) {\n    return _objectSpread2({}, aCommand);\n  });\n\n  if (addZ) {\n    interpolatedCommands.push({\n      type: 'Z'\n    });\n    aCommands.push({\n      type: 'Z'\n    }); // required for when returning at t == 0\n  }\n\n  return function pathCommandInterpolator(t) {\n    // at 1 return the final value without the extensions used during interpolation\n    if (t === 1) {\n      return bCommandsInput == null ? [] : bCommandsInput;\n    } // work with aCommands directly since interpolatedCommands are mutated\n\n\n    if (t === 0) {\n      return aCommands;\n    } // interpolate the commands using the mutable interpolated command objs\n\n\n    for (var i = 0; i < interpolatedCommands.length; ++i) {\n      // if (interpolatedCommands[i].type === 'Z') continue;\n      var aCommand = aCommands[i];\n      var bCommand = bCommands[i];\n      var interpolatedCommand = interpolatedCommands[i];\n\n      var _iterator = _createForOfIteratorHelper(typeMap[interpolatedCommand.type]),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var arg = _step.value;\n          interpolatedCommand[arg] = (1 - t) * aCommand[arg] + t * bCommand[arg]; // do not use floats for flags (#27), round to integer\n\n          if (arg === 'largeArcFlag' || arg === 'sweepFlag') {\n            interpolatedCommand[arg] = Math.round(interpolatedCommand[arg]);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    return interpolatedCommands;\n  };\n}\n/**\n * Interpolate from A to B by extending A and B during interpolation to have\n * the same number of points. This allows for a smooth transition when they\n * have a different number of points.\n *\n * Ignores the `Z` character in paths unless both A and B end with it.\n *\n * @param {String} a The `d` attribute for a path\n * @param {String} b The `d` attribute for a path\n * @param {Function} excludeSegment a function that takes a start command object and\n *   end command object and returns true if the segment should be excluded from splitting.\n * @returns {Function} Interpolation function that maps t ([0, 1]) to a path `d` string.\n */\n\nfunction interpolatePath(a, b, excludeSegment) {\n  var aCommands = pathCommandsFromString(a);\n  var bCommands = pathCommandsFromString(b);\n\n  if (!aCommands.length && !bCommands.length) {\n    return function nullInterpolator() {\n      return '';\n    };\n  }\n\n  var commandInterpolator = interpolatePathCommands(aCommands, bCommands, excludeSegment);\n  return function pathStringInterpolator(t) {\n    // at 1 return the final value without the extensions used during interpolation\n    if (t === 1) {\n      return b == null ? '' : b;\n    }\n\n    var interpolatedCommands = commandInterpolator(t); // convert to a string (fastest concat: https://jsperf.com/join-concat/150)\n\n    var interpolatedString = '';\n\n    var _iterator2 = _createForOfIteratorHelper(interpolatedCommands),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var interpolatedCommand = _step2.value;\n        interpolatedString += commandToString(interpolatedCommand);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return interpolatedString;\n  };\n}\n\nexport { interpolatePath, interpolatePathCommands, pathCommandsFromString };\n"]},"metadata":{},"sourceType":"module"}
/*!
  Modus React Bootstrap 
  A React-based component library developed as a common, open source platform for all of Trimbleâ€™s web applications built on React.
  Extends React-Bootstrap v1.6.5
  Copyright (c) 2022 Trimble Inc.
 */

import React, { forwardRef, useCallback, useMemo, useRef, useState } from 'react';
import classNames from 'classnames';
import Form from './Form';
import Button from './Button';
import { jsx as _jsx } from "react/jsx-runtime";
import { jsxs as _jsxs } from "react/jsx-runtime";
import { Fragment as _Fragment } from "react/jsx-runtime";
const DEFAULT = {
  value: 'default'
};
function bytesToSize(bytes) {
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
  if (bytes === 0) return 'n/a';
  const i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)).toString(), 10);
  if (i === 0) return `${bytes} ${sizes[i]}`;
  return `${(bytes / 1024 ** i).toFixed(1)} ${sizes[i]}`;
}
function validateFiles(files, accept, maxFileCount, maxTotalFileSizeBytes, multiple) {
  if (files) {
    const arr = Array.from(files);

    // Accepted File types
    if (accept) {
      const acceptArray = accept.split(',');
      const acceptedTypes = new Set(acceptArray);
      const fileExtensionRegExp = new RegExp('.[0-9a-z]+$', 'i');
      const validMimeTypeExp = new RegExp(/[a-z]+\/\*/);
      const invalidType = arr.find(({
        name,
        type
      }) => {
        const hasFileExtension = fileExtensionRegExp.test(name);
        if (!hasFileExtension) {
          return true;
        }
        const [fileExtension] = name.match(fileExtensionRegExp) || [];
        if (acceptedTypes.has(type) || fileExtension && acceptedTypes.has(fileExtension.toLowerCase())) {
          return false;
        }
        const acceptedMimeTypes = acceptArray.map(i => i.match(validMimeTypeExp)).filter(i => i);
        const hasValidMimeType = acceptedMimeTypes.find(matchArray => {
          const [media] = matchArray || [];
          const mediaMatchExp = new RegExp(`(^${media})[a-zA-Z0-9_]*`);
          if (type.match(mediaMatchExp)) return true;
          return false;
        });
        return !hasValidMimeType;
      });
      if (invalidType) {
        return `Some files do not match the allowed file types (${acceptArray.map((item, index) => `${item}${index === accept.length - 1 ? '' : ','}`).join(' ')}).`;
      }
    }

    // Files count
    if (maxFileCount && arr.length > maxFileCount) {
      return `Max file upload limit of ${maxFileCount} files exceeded.`;
    }

    // Multiple upload
    if (!multiple && !maxFileCount && arr.length > 1) {
      return `Multiple files cannot be uploaded.`;
    }

    // Total size
    if (maxTotalFileSizeBytes) {
      const totalSize = arr.reduce((tot, file) => tot + file.size, 0);
      if (totalSize > maxTotalFileSizeBytes) return `Upload size exceeds limit. Max upload size ${bytesToSize(maxTotalFileSizeBytes)}.`;
    }
  }
  return null;
}
const FileUploadDropZone = /*#__PURE__*/forwardRef(({
  id,
  maxFileCount,
  maxTotalFileSizeBytes,
  multiple,
  disabled,
  className,
  tabIndex,
  accept,
  uploadIcon,
  onFiles,
  onDragEnter,
  onDragLeave,
  onDragOver,
  validator,
  ...props
}, ref) => {
  const defaultRef = useRef(null);
  const resolvedRef = defaultRef || ref;
  const fileInputRef = useRef(null);

  // workaround for onDragLeave firing on parent div when dragging over a child div
  const dragCounter = useRef(0);
  const [state, setState] = useState(DEFAULT);
  const finalUploadIcon = useMemo(() => {
    if (typeof uploadIcon === 'boolean') {
      if (!uploadIcon) return null;
    } else if (uploadIcon !== undefined) return uploadIcon;
    return /*#__PURE__*/_jsx("i", {
      className: "modus-icons",
      children: "cloud_upload"
    });
  }, [uploadIcon]);
  const handleDragEnter = useCallback(e => {
    setState({
      value: 'drop',
      message: 'Drag files here.'
    });
    dragCounter.current++;
    e.preventDefault();
    if (onDragEnter) onDragEnter(e);
  }, [setState, onDragEnter]);
  const handleDragLeave = useCallback(e => {
    // workaround for onDragLeave firing on parent div when dragging over a child div
    dragCounter.current--;
    if (dragCounter.current === 0) {
      setState(DEFAULT);
    }
    e.preventDefault();
    if (onDragLeave) onDragLeave(e);
  }, [setState, onDragLeave]);
  const handleDragOver = useCallback(e => {
    e.preventDefault();
    if (onDragOver) onDragOver(e);
  }, [onDragOver]);
  const handleFiles = useCallback(files => {
    const err = validator ? validator(files) : validateFiles(files, accept, maxFileCount, maxTotalFileSizeBytes, multiple);
    if (err) {
      setState({
        value: 'error',
        icon: /*#__PURE__*/_jsx("i", {
          className: "modus-icons",
          children: "no_entry"
        }),
        message: err
      });
    } else setState(DEFAULT);
    if (onFiles) onFiles(files, err);
  }, [setState, onFiles, validator, accept, maxFileCount, maxTotalFileSizeBytes, multiple]);
  const handleDrop = useCallback(e => {
    e.preventDefault();
    handleFiles(e.dataTransfer.files);
    dragCounter.current = 0;
  }, [handleFiles]);
  const handleKeyDown = useCallback(e => {
    if (fileInputRef.current && !disabled && (e.key === 'Enter' || e.key === ' ')) fileInputRef.current.click();
  }, [disabled]);
  const handleReset = useCallback(e => {
    if (!e.key || e.key === 'Enter' || e.key === ' ') {
      setState(DEFAULT);
      dragCounter.current = 0;
      e.preventDefault();
      e.stopPropagation();
    }
  }, [setState, dragCounter]);
  const events = useMemo(() => disabled ? {} : {
    onDragEnter(e) {
      handleDragEnter(e);
    },
    onDragOver(e) {
      handleDragOver(e);
    },
    onDragLeave(e) {
      handleDragLeave(e);
    },
    onDrop(e) {
      handleDrop(e);
    },
    onKeyDown(e) {
      handleKeyDown(e);
    }
  }, [disabled, handleDragEnter, handleDragOver, handleDragLeave, handleDrop, handleKeyDown]);
  return /*#__PURE__*/_jsx("div", {
    ...events,
    ...props,
    ref: resolvedRef,
    className: classNames('mrb-file-upload-drop-zone d-flex flex-column justify-content-center text-center', disabled && 'disabled' || state && state.value, className),
    tabIndex: tabIndex || 0,
    "aria-label": props['aria-label'] || 'Drop Zone',
    "aria-disabled": props['aria-disabled'] ? props['aria-disabled'] : disabled,
    children: state && /*#__PURE__*/_jsxs(_Fragment, {
      children: [state.icon || finalUploadIcon, state.message, /*#__PURE__*/_jsxs("div", {
        className: classNames(state.message && 'd-none'),
        children: ["Drag files here or", ' ', /*#__PURE__*/_jsxs(Form.File, {
          id: id,
          className: "p-0 m-0 d-inline",
          disabled: disabled,
          children: [/*#__PURE__*/_jsx(Form.File.Label, {
            className: "p-0 m-0 browse",
            tabIndex: 0,
            "aria-label": "browse",
            "aria-disabled": props['aria-disabled'] ? props['aria-disabled'] : disabled,
            children: "browse"
          }), /*#__PURE__*/_jsx(Form.File.Input, {
            className: "d-none",
            disabled: disabled,
            ref: fileInputRef,
            onChange: e => handleFiles(e.target.files),
            multiple: multiple || Boolean(maxFileCount && maxFileCount > 1),
            accept: accept
          })]
        }), ' ', "to upload."]
      }), state.value === 'error' && /*#__PURE__*/_jsx("div", {
        className: "reset-btn-container",
        children: /*#__PURE__*/_jsx(Button, {
          variant: "outline-secondary",
          size: "sm",
          onClick: handleReset,
          onKeyDown: handleReset,
          children: "Reset"
        })
      })]
    })
  });
});
FileUploadDropZone.displayName = 'FileUploadDropZone';
export default FileUploadDropZone;
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.DataTableDragDropContext = void 0;
exports.default = DataTableDragdropProvider;
var _react = _interopRequireWildcard(require("react"));
var _useForceUpdate = _interopRequireDefault(require("@restart/hooks/useForceUpdate"));
var _renderUsingPortal = _interopRequireDefault(require("./renderUsingPortal"));
var _jsxRuntime = require("react/jsx-runtime");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/*!
  Modus React Bootstrap 
  A React-based component library developed as a common, open source platform for all of Trimbleâ€™s web applications built on React.
  Extends React-Bootstrap v1.6.5
  Copyright (c) 2022 Trimble Inc.
 */

const POSITION = {
  x: 0,
  y: 0
};
function getNewColumnOrder(columnIds, dragColumnId, dropColumnId) {
  const newColumnOrder = columnIds;
  newColumnOrder.splice(columnIds.indexOf(dragColumnId), 1);
  newColumnOrder.splice(newColumnOrder.indexOf(dropColumnId), 0, dragColumnId);
  return newColumnOrder;
}
function getDragContent(dragState, dragItemTemplate) {
  if (dragState.isDragging && dragState.column) {
    const dragContainerStyle = {
      width: dragState.width,
      height: dragState.height,
      transform: `translate(calc(${dragState.translation.x}px - 10%), calc(${dragState.translation.y}px - 50%))`,
      msTransform: `translateX(${dragState.translation.x}px) translateX(-10%) translateY(${dragState.translation.y}px) translateY(-50%)`,
      zIndex: 9999,
      left: 0,
      top: 0,
      position: 'fixed',
      cursor: dragState.isDragging ? '-webkit-grabbing' : '-webkit-grab',
      visibility: dragState.visible ? 'visible' : 'hidden',
      opacity: '0.9'
    };
    const dragContentStyle = {
      width: dragState.width,
      height: dragState.height
    };
    return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      style: dragContainerStyle,
      children: dragItemTemplate ? dragItemTemplate(dragState.column) : /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        style: dragContentStyle,
        className: "bg-gray-light p-2",
        children: dragState.column.render('Header')
      })
    });
  }
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {});
}
function isWithInBounds(boundingClientRect, x, y) {
  if (boundingClientRect) {
    const inVerticalBounds = y >= boundingClientRect.top && y <= boundingClientRect.bottom;
    const inHorizontalBounds = x >= boundingClientRect.left && x <= boundingClientRect.right;
    return inVerticalBounds && inHorizontalBounds;
  }
  return false;
}
const DataTableDragDropContext = /*#__PURE__*/_react.default.createContext(null);
exports.DataTableDragDropContext = DataTableDragDropContext;
function DataTableDragdropProvider(props) {
  const {
    children,
    visibleColumns,
    setColumnOrder,
    dragItemTemplate
  } = props;
  const forceUpdate = (0, _useForceUpdate.default)();
  const registeredColumns = (0, _react.useRef)([]);
  const droppingState = (0, _react.useRef)({
    column: null,
    validTarget: false
  });
  const draggingState = (0, _react.useRef)({
    isDragging: false,
    visible: false,
    origin: POSITION,
    translation: POSITION,
    width: '0px',
    height: '0px',
    column: null,
    columnOrder: visibleColumns.map(d => d.id)
  });
  function clearDroppingState() {
    const prevDropState = droppingState.current;
    if (droppingState.current.column) {
      droppingState.current.column.ref.classList.remove('drop-allow');
      droppingState.current.column.ref.classList.remove('drop-block');
    }
    droppingState.current = {
      column: null,
      validTarget: false
    };
    return prevDropState;
  }
  const getDroppableColumn = (0, _react.useCallback)((x, y) => {
    const column = registeredColumns.current.find(({
      ref
    }) => {
      const rect = ref.getBoundingClientRect();
      return isWithInBounds(rect, x, y);
    });
    return column;
  }, []);
  const registerColumn = (0, _react.useCallback)((id, ref) => {
    const refs = registeredColumns.current ? registeredColumns.current.filter(col => col.id !== id) : [];
    refs.push({
      id,
      ref
    });
    registeredColumns.current = refs;
  }, []);
  const handleMouseDown = (0, _react.useCallback)((event, column) => {
    const {
      clientX,
      clientY,
      target,
      nativeEvent
    } = event;
    if (nativeEvent.which !== 1) return;
    const prevDragState = draggingState.current;
    clearDroppingState();
    draggingState.current = {
      ...prevDragState,
      isDragging: true,
      origin: {
        x: clientX,
        y: clientY
      },
      column,
      width: target && target.offsetParent && target.offsetParent.width || '80px',
      height: target && target.offsetParent && target.offsetParent.height || '3rem',
      columnOrder: visibleColumns.map(d => d.id)
    };
    forceUpdate();
  }, [forceUpdate, visibleColumns]);
  const handleMouseMove = (0, _react.useCallback)(({
    clientX,
    clientY
  }) => {
    clearDroppingState();
    const prevDragState = draggingState.current;
    const translation = {
      x: clientX,
      y: clientY
    };
    if (!prevDragState.column) return;
    const droppableColumn = getDroppableColumn(clientX, clientY);
    if (droppableColumn) {
      const column = visibleColumns.find(d => d.id === droppableColumn.id);
      const isDroppable = column.allowDrop || (column.allowDropForColumns || []).includes(prevDragState.column.id);
      droppingState.current.column = droppableColumn;
      droppingState.current.validTarget = isDroppable;
      droppableColumn.ref.classList.add(isDroppable ? 'drop-allow' : 'drop-block');
    }
    draggingState.current = {
      ...prevDragState,
      visible: true,
      translation
    };
    forceUpdate();
  }, [forceUpdate, getDroppableColumn, visibleColumns]);
  const handleMouseUp = (0, _react.useCallback)(() => {
    const prevDragState = draggingState.current;
    const prevDropState = droppingState.current;
    if (prevDropState.validTarget && prevDropState.column && prevDragState.column && prevDropState.column.id !== prevDragState.column.id) {
      const columnIds = getNewColumnOrder(prevDragState.columnOrder, prevDragState.column.id, prevDropState.column.id);
      setColumnOrder(columnIds);
    }
    draggingState.current = {
      ...prevDragState,
      isDragging: false,
      visible: false,
      translation: POSITION,
      column: null
    };
    clearDroppingState();
    forceUpdate();
  }, [forceUpdate, setColumnOrder]);
  const value = (0, _react.useMemo)(() => ({
    dragColumnId: draggingState.current.column ? draggingState.current.column.id : null,
    onHeaderDragStart: handleMouseDown,
    registerColumn
  }),
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [draggingState.current.column, handleMouseDown, registerColumn]);
  (0, _react.useEffect)(() => {
    if (draggingState.current.isDragging) {
      window.addEventListener('mousemove', handleMouseMove);
      window.addEventListener('mouseup', handleMouseUp);
    } else {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', handleMouseUp);
    }
  }, [draggingState.current.isDragging, handleMouseMove, handleMouseUp]);
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(DataTableDragDropContext.Provider, {
    value: value,
    children: [children, (0, _renderUsingPortal.default)(draggingState.current.isDragging ? getDragContent(draggingState.current, dragItemTemplate) : null, document.body)]
  });
}
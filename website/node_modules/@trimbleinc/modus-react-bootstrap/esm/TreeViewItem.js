/*!
  Modus React Bootstrap 
  A React-based component library developed as a common, open source platform for all of Trimbleâ€™s web applications built on React.
  Extends React-Bootstrap v1.6.5
  Copyright (c) 2022 Trimble Inc.
 */

import React, { useContext, useEffect, useMemo, useRef, useState } from 'react';
import classNames from 'classnames';
import TreeViewContext from './TreeViewContext';
import TreeViewItemContext from './TreeViewItemContext';
import { TreeViewItemStyled } from './TreeViewItemStyled';
import useDescendants from './useTreeViewDescendants';
import IndeterminateCheckbox from './IndeterminateCheckbox';
import { jsx as _jsx } from "react/jsx-runtime";
import { jsxs as _jsxs } from "react/jsx-runtime";
function getAllNodeIds(array) {
  if (!array) return [];
  return array.reduce((r, {
    id,
    children
  }) => {
    r.push(id, ...getAllNodeIds(children));
    return r;
  }, []);
}
function noop() {
  // do nothing
}
const ContentWrapper = ({
  className,
  children,
  ...props
}) => /*#__PURE__*/_jsx("div", {
  className: classNames('d-flex align-items-center', className),
  ...props,
  children: children
});
const TreeViewItem = /*#__PURE__*/React.forwardRef(({
  className,
  children,
  nodeId,
  label,
  collapseIcon,
  expandIcon,
  itemIcon,
  dragIcon,
  disabled,
  ...rest
}, ref) => {
  const treeViewContext = useContext(TreeViewContext);
  const {
    id: rootId,
    size,
    registerNode,
    unRegisterNode,
    isExpanded,
    isNodeInFocus,
    isNodeSelected,
    isCheckBoxSelected,
    toggleExpansion,
    toggleNodeSelection,
    toggleSingleCheckBoxSelection,
    toggleMultiCheckBoxSelection,
    focusNode,
    onKeyPress,
    isIndeterminate,
    checkBoxSelection,
    multiSelectCheckBox,
    collapseIcon: defaultCollapseIcon,
    expandIcon: defaultExpandIcon,
    itemIcon: defaultItemIcon,
    dragIcon: defaultDragIcon
  } = treeViewContext || {};
  const defaultRef = React.useRef(null);
  const resolvedRef = ref || defaultRef;

  // Used while navigating through keyboard interactions to decide whether to trigger focus on the tree item or not
  // value will be null until a focus event occurs
  const focusSource = useRef(null);

  // Used by descendant context to find the index of repositioned elements
  const [treeItemElement, setTreeItemElement] = useState(null);
  const expandable = Boolean(Array.isArray(children) ? children.length : children);
  const expanded = isExpanded ? isExpanded(nodeId) : false;
  const nodeSelected = isNodeSelected ? isNodeSelected(nodeId) : false;
  const checkBoxSelected = isCheckBoxSelected ? isCheckBoxSelected(nodeId) : false;
  const checkBoxIndeterminate = checkBoxSelection && expandable && isIndeterminate ? isIndeterminate(nodeId) : false;
  const inFocus = isNodeInFocus && isNodeInFocus(nodeId);
  const finalExpandIcon = expandIcon || defaultExpandIcon || /*#__PURE__*/_jsx("i", {
    className: "modus-icons",
    children: "chevron_down_thick"
  });
  const finalCollapseIcon = collapseIcon || defaultCollapseIcon || /*#__PURE__*/_jsx("i", {
    className: "modus-icons",
    children: "chevron_right"
  });
  const finalItemIcon = itemIcon || defaultItemIcon;
  const finalDragIcon = dragIcon || defaultDragIcon;
  const blankIcon = /*#__PURE__*/_jsx("i", {
    className: "modus-icons",
    children: "blank"
  });
  const defaultTabIndex = disabled ? -1 : 0;
  const ariaLabel = rest['aria-label'] || 'Tree Item';
  const {
    parentId,
    level,
    index,
    descendants,
    updateCheckboxSelectionOnParent,
    ...descendantContext
  } = useDescendants({
    nodeId,
    element: treeItemElement,
    hasCheckBoxSelected: isCheckBoxSelected,
    handleCheckboxSelection: toggleMultiCheckBoxSelection
  });
  const currentLevel = level !== undefined ? level : 0;
  useEffect(() => {
    if (registerNode) registerNode({
      id: nodeId,
      parentId,
      label,
      disabled,
      index
    });
    return () => {
      if (unRegisterNode) unRegisterNode(nodeId);
    };
  }, [registerNode, unRegisterNode, nodeId, parentId, label, disabled, index]);

  // This effect is used for focussing the tree item element while using keyboard interactions like arrow up/down key
  useEffect(() => {
    const ele = resolvedRef.current;
    if (inFocus && !focusSource.current && ele) {
      ele.firstChild.focus();
    }
  }, [inFocus, resolvedRef]);
  useEffect(() => {
    if (resolvedRef.current) setTreeItemElement(resolvedRef.current);
  }, [resolvedRef]);
  const showIndicator = useMemo(() => {
    if (!isNodeSelected) return false;
    if (isNodeSelected(nodeId)) return true;
    return !expanded && descendants && getAllNodeIds(descendants).find(d => isNodeSelected(d));
  }, [descendants, isNodeSelected, nodeId, expanded]);
  const handleNodeSelection = React.useCallback(e => {
    if (toggleNodeSelection) toggleNodeSelection(e, nodeId);
  }, [toggleNodeSelection, nodeId]);
  const handleCheckBoxSelection = React.useCallback(e => {
    e.stopPropagation();
    if (multiSelectCheckBox) {
      const all = [...getAllNodeIds(descendants), nodeId];
      let checked = [];
      let unchecked = [];

      // toggle checkbox selection on children
      if (isCheckBoxSelected && isCheckBoxSelected(nodeId)) unchecked = all;else checked = all;

      // if parent is not a root node update checkbox selection state at the parent node
      if (updateCheckboxSelectionOnParent) updateCheckboxSelectionOnParent(e, nodeId, checked, unchecked);else if (toggleMultiCheckBoxSelection) toggleMultiCheckBoxSelection(e, checked, unchecked);
    } else if (toggleSingleCheckBoxSelection) toggleSingleCheckBoxSelection(e, nodeId);
  }, [descendants, multiSelectCheckBox, isCheckBoxSelected, toggleSingleCheckBoxSelection, toggleMultiCheckBoxSelection, updateCheckboxSelectionOnParent, nodeId]);
  const handleExpansion = React.useCallback(e => {
    e.stopPropagation();
    if (toggleExpansion) toggleExpansion(e, nodeId);
  }, [toggleExpansion, nodeId]);
  const handleFocus = React.useCallback(e => {
    // do not update focus state if it is in a disabled state or if already in focus
    if (disabled || inFocus) return;
    focusSource.current = e.target;
    if (focusNode) focusNode(nodeId);
    e.preventDefault();
  }, [disabled, inFocus, focusNode, nodeId]);
  const handleBlur = React.useCallback(() => {
    focusSource.current = null;
  }, []);
  const stopPropagation = React.useCallback((e, flag) => flag && e.stopPropagation(), []);
  return /*#__PURE__*/_jsxs("li", {
    className: classNames('mrb-tree-view-item d-flex flex-column', showIndicator && 'selected-indicator', className),
    ref: resolvedRef,
    role: "treeitem",
    "aria-expanded": expandable ? expanded : undefined,
    "aria-selected": nodeSelected,
    "aria-disabled": disabled,
    "aria-level": currentLevel,
    "aria-label": ariaLabel,
    ...rest,
    children: [/*#__PURE__*/_jsxs(TreeViewItemStyled, {
      level: currentLevel,
      hasCheckBoxSelection: checkBoxSelection ? 'true' : 'false',
      hasItemIcon: finalItemIcon ? 'true' : 'false',
      className: classNames('list-group-item list-item-leftright-control w-100', nodeSelected && 'active', disabled && 'disabled', className),
      tabIndex: defaultTabIndex,
      onFocus: handleFocus,
      onBlur: handleBlur,
      onKeyDown: e => {
        if (e.target === e.currentTarget && onKeyPress && toggleNodeSelection) onKeyPress(e, () => toggleNodeSelection(e, nodeId));
      },
      onClick: handleNodeSelection,
      style: {
        marginTop: '-1px',
        marginBottom: '-1px'
      },
      children: [/*#__PURE__*/_jsxs(ContentWrapper, {
        children: [/*#__PURE__*/_jsx("div", {
          className: "d-inline-flex",
          tabIndex: finalDragIcon ? defaultTabIndex : -1,
          onClick: e => stopPropagation(e, !!finalDragIcon),
          role: "button",
          "aria-label": "Drag the item",
          "aria-hidden": !finalDragIcon,
          children: finalDragIcon || blankIcon
        }), /*#__PURE__*/_jsx("div", {
          className: "d-inline-flex item-indent h-100 align-items-center",
          tabIndex: expandable ? defaultTabIndex : -1,
          onKeyDown: e => {
            if (onKeyPress && toggleExpansion) onKeyPress(e, () => toggleExpansion(e, nodeId));
          },
          onClick: expandable ? handleExpansion : noop,
          onFocus: noop // to retain focus
          ,
          role: "button",
          "aria-label": "Expand/Collapse",
          "aria-hidden": !expandable,
          children: expandable ? expanded && finalExpandIcon || finalCollapseIcon : blankIcon
        })]
      }), checkBoxSelection && /*#__PURE__*/_jsx(ContentWrapper, {
        onClick: e => stopPropagation(e, true),
        children: /*#__PURE__*/_jsx(IndeterminateCheckbox, {
          "aria-label": `${checkBoxSelected ? 'Select' : 'Unselect'} ${ariaLabel}`,
          checked: checkBoxSelected,
          id: `${rootId}_cbselection_${nodeId}`,
          indeterminate: checkBoxIndeterminate,
          tabIndex: defaultTabIndex,
          onKeyDown: e => {
            if (e.key !== ' ' && onKeyPress) onKeyPress(e, () => handleCheckBoxSelection(e));
          },
          onChange: handleCheckBoxSelection,
          onFocus: noop // to retain focus
          ,
          size: size
        })
      }), finalItemIcon && /*#__PURE__*/_jsx(ContentWrapper, {
        tabIndex: defaultTabIndex,
        onClick: e => stopPropagation(e, true),
        children: finalItemIcon
      }), /*#__PURE__*/_jsx(ContentWrapper, {
        role: "heading",
        "aria-level": currentLevel,
        children: /*#__PURE__*/_jsx("div", {
          role: "button",
          className: "w-100",
          children: label
        })
      })]
    }), children && /*#__PURE__*/_jsx(TreeViewItemContext.Provider, {
      value: {
        level: currentLevel + 1,
        parentId: nodeId,
        ...descendantContext
      },
      children: /*#__PURE__*/_jsx("ul", {
        role: "tree",
        className: classNames('list-group w-100 h-100', !expanded && 'd-none'),
        style: {
          marginTop: '-1px',
          marginBottom: '-1px'
        },
        children: children
      })
    })]
  });
});
TreeViewItem.displayName = 'TreeViewItem';
export default TreeViewItem;
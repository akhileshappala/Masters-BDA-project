"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
var _classnames = _interopRequireDefault(require("classnames"));
var _Form = _interopRequireDefault(require("./Form"));
var _Button = _interopRequireDefault(require("./Button"));
var _jsxRuntime = require("react/jsx-runtime");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/*!
  Modus React Bootstrap 
  A React-based component library developed as a common, open source platform for all of Trimbleâ€™s web applications built on React.
  Extends React-Bootstrap v1.6.5
  Copyright (c) 2022 Trimble Inc.
 */

const DEFAULT = {
  value: 'default'
};
function bytesToSize(bytes) {
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
  if (bytes === 0) return 'n/a';
  const i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)).toString(), 10);
  if (i === 0) return `${bytes} ${sizes[i]}`;
  return `${(bytes / 1024 ** i).toFixed(1)} ${sizes[i]}`;
}
function validateFiles(files, accept, maxFileCount, maxTotalFileSizeBytes, multiple) {
  if (files) {
    const arr = Array.from(files);

    // Accepted File types
    if (accept) {
      const acceptArray = accept.split(',');
      const acceptedTypes = new Set(acceptArray);
      const fileExtensionRegExp = new RegExp('.[0-9a-z]+$', 'i');
      const validMimeTypeExp = new RegExp(/[a-z]+\/\*/);
      const invalidType = arr.find(({
        name,
        type
      }) => {
        const hasFileExtension = fileExtensionRegExp.test(name);
        if (!hasFileExtension) {
          return true;
        }
        const [fileExtension] = name.match(fileExtensionRegExp) || [];
        if (acceptedTypes.has(type) || fileExtension && acceptedTypes.has(fileExtension.toLowerCase())) {
          return false;
        }
        const acceptedMimeTypes = acceptArray.map(i => i.match(validMimeTypeExp)).filter(i => i);
        const hasValidMimeType = acceptedMimeTypes.find(matchArray => {
          const [media] = matchArray || [];
          const mediaMatchExp = new RegExp(`(^${media})[a-zA-Z0-9_]*`);
          if (type.match(mediaMatchExp)) return true;
          return false;
        });
        return !hasValidMimeType;
      });
      if (invalidType) {
        return `Some files do not match the allowed file types (${acceptArray.map((item, index) => `${item}${index === accept.length - 1 ? '' : ','}`).join(' ')}).`;
      }
    }

    // Files count
    if (maxFileCount && arr.length > maxFileCount) {
      return `Max file upload limit of ${maxFileCount} files exceeded.`;
    }

    // Multiple upload
    if (!multiple && !maxFileCount && arr.length > 1) {
      return `Multiple files cannot be uploaded.`;
    }

    // Total size
    if (maxTotalFileSizeBytes) {
      const totalSize = arr.reduce((tot, file) => tot + file.size, 0);
      if (totalSize > maxTotalFileSizeBytes) return `Upload size exceeds limit. Max upload size ${bytesToSize(maxTotalFileSizeBytes)}.`;
    }
  }
  return null;
}
const FileUploadDropZone = /*#__PURE__*/(0, _react.forwardRef)(({
  id,
  maxFileCount,
  maxTotalFileSizeBytes,
  multiple,
  disabled,
  className,
  tabIndex,
  accept,
  uploadIcon,
  onFiles,
  onDragEnter,
  onDragLeave,
  onDragOver,
  validator,
  ...props
}, ref) => {
  const defaultRef = (0, _react.useRef)(null);
  const resolvedRef = defaultRef || ref;
  const fileInputRef = (0, _react.useRef)(null);

  // workaround for onDragLeave firing on parent div when dragging over a child div
  const dragCounter = (0, _react.useRef)(0);
  const [state, setState] = (0, _react.useState)(DEFAULT);
  const finalUploadIcon = (0, _react.useMemo)(() => {
    if (typeof uploadIcon === 'boolean') {
      if (!uploadIcon) return null;
    } else if (uploadIcon !== undefined) return uploadIcon;
    return /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
      className: "modus-icons",
      children: "cloud_upload"
    });
  }, [uploadIcon]);
  const handleDragEnter = (0, _react.useCallback)(e => {
    setState({
      value: 'drop',
      message: 'Drag files here.'
    });
    dragCounter.current++;
    e.preventDefault();
    if (onDragEnter) onDragEnter(e);
  }, [setState, onDragEnter]);
  const handleDragLeave = (0, _react.useCallback)(e => {
    // workaround for onDragLeave firing on parent div when dragging over a child div
    dragCounter.current--;
    if (dragCounter.current === 0) {
      setState(DEFAULT);
    }
    e.preventDefault();
    if (onDragLeave) onDragLeave(e);
  }, [setState, onDragLeave]);
  const handleDragOver = (0, _react.useCallback)(e => {
    e.preventDefault();
    if (onDragOver) onDragOver(e);
  }, [onDragOver]);
  const handleFiles = (0, _react.useCallback)(files => {
    const err = validator ? validator(files) : validateFiles(files, accept, maxFileCount, maxTotalFileSizeBytes, multiple);
    if (err) {
      setState({
        value: 'error',
        icon: /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
          className: "modus-icons",
          children: "no_entry"
        }),
        message: err
      });
    } else setState(DEFAULT);
    if (onFiles) onFiles(files, err);
  }, [setState, onFiles, validator, accept, maxFileCount, maxTotalFileSizeBytes, multiple]);
  const handleDrop = (0, _react.useCallback)(e => {
    e.preventDefault();
    handleFiles(e.dataTransfer.files);
    dragCounter.current = 0;
  }, [handleFiles]);
  const handleKeyDown = (0, _react.useCallback)(e => {
    if (fileInputRef.current && !disabled && (e.key === 'Enter' || e.key === ' ')) fileInputRef.current.click();
  }, [disabled]);
  const handleReset = (0, _react.useCallback)(e => {
    if (!e.key || e.key === 'Enter' || e.key === ' ') {
      setState(DEFAULT);
      dragCounter.current = 0;
      e.preventDefault();
      e.stopPropagation();
    }
  }, [setState, dragCounter]);
  const events = (0, _react.useMemo)(() => disabled ? {} : {
    onDragEnter(e) {
      handleDragEnter(e);
    },
    onDragOver(e) {
      handleDragOver(e);
    },
    onDragLeave(e) {
      handleDragLeave(e);
    },
    onDrop(e) {
      handleDrop(e);
    },
    onKeyDown(e) {
      handleKeyDown(e);
    }
  }, [disabled, handleDragEnter, handleDragOver, handleDragLeave, handleDrop, handleKeyDown]);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    ...events,
    ...props,
    ref: resolvedRef,
    className: (0, _classnames.default)('mrb-file-upload-drop-zone d-flex flex-column justify-content-center text-center', disabled && 'disabled' || state && state.value, className),
    tabIndex: tabIndex || 0,
    "aria-label": props['aria-label'] || 'Drop Zone',
    "aria-disabled": props['aria-disabled'] ? props['aria-disabled'] : disabled,
    children: state && /*#__PURE__*/(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
      children: [state.icon || finalUploadIcon, state.message, /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: (0, _classnames.default)(state.message && 'd-none'),
        children: ["Drag files here or", ' ', /*#__PURE__*/(0, _jsxRuntime.jsxs)(_Form.default.File, {
          id: id,
          className: "p-0 m-0 d-inline",
          disabled: disabled,
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_Form.default.File.Label, {
            className: "p-0 m-0 browse",
            tabIndex: 0,
            "aria-label": "browse",
            "aria-disabled": props['aria-disabled'] ? props['aria-disabled'] : disabled,
            children: "browse"
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_Form.default.File.Input, {
            className: "d-none",
            disabled: disabled,
            ref: fileInputRef,
            onChange: e => handleFiles(e.target.files),
            multiple: multiple || Boolean(maxFileCount && maxFileCount > 1),
            accept: accept
          })]
        }), ' ', "to upload."]
      }), state.value === 'error' && /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "reset-btn-container",
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_Button.default, {
          variant: "outline-secondary",
          size: "sm",
          onClick: handleReset,
          onKeyDown: handleReset,
          children: "Reset"
        })
      })]
    })
  });
});
FileUploadDropZone.displayName = 'FileUploadDropZone';
var _default = FileUploadDropZone;
exports.default = _default;
module.exports = exports.default;
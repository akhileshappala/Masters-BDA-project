"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = useTreeViewDescendants;
var _react = require("react");
var _lodash = require("lodash");
var _TreeViewItemContext = _interopRequireDefault(require("./TreeViewItemContext"));
/*!
  Credit: https://github.com/reach/reach-ui/blob/86a046f54d53b6420e392b3fa56dd991d9d4e458/packages/descendants/README.md
  Modified to suit our purposes.

  Modus React Bootstrap 
  A React-based component library developed as a common, open source platform for all of Trimbleâ€™s web applications built on React.
  Extends React-Bootstrap v1.6.5
  Copyright (c) 2022 Trimble Inc.
 */

/**
 * useTreeViewDescendants:
 * A custom hook to enable TreeViewItem to
 *  - maintain details about its descendants
 *  - update the state in parent TreeViewItem or root TreeView
 */

function binaryFindElement(array, findElement) {
  let start = 0;
  let end = array.length - 1;
  while (start <= end) {
    const middle = Math.floor((start + end) / 2);
    if (array[middle].element === findElement) {
      return middle;
    }

    // eslint-disable-next-line no-bitwise
    if (array[middle].element && array[middle].element.compareDocumentPosition(findElement) && Node.DOCUMENT_POSITION_PRECEDING) {
      end = middle - 1;
    } else {
      start = middle + 1;
    }
  }
  return start;
}
function useTreeViewDescendants({
  nodeId,
  element,
  hasCheckBoxSelected,
  handleCheckboxSelection
}) {
  const registeredChildren = (0, _react.useRef)([]);
  const hasRegisteredFlag = (0, _react.useRef)(false);

  // will be -1 until the node is registered in the parent
  const [index, setIndex] = (0, _react.useState)(-1);

  // descendant context methods from the parent node if any
  const treeItemContext = (0, _react.useContext)(_TreeViewItemContext.default);
  const {
    parentId,
    level,
    registerDescendant: registerOnParent,
    unRegisterDescendant: unRegisterOnParent,
    updateDescendant: updateParent,
    updateCheckboxSelection: updateCheckboxSelectionOnParent
  } = treeItemContext || {};

  /* eslint-disable react-hooks/exhaustive-deps */
  const descendants = (0, _react.useMemo)(() => registeredChildren.current, [registeredChildren.current]);
  /* eslint-disable react-hooks/exhaustive-deps */

  (0, _react.useEffect)(() => {
    if (registerOnParent && element) {
      hasRegisteredFlag.current = true;
      const newIndex = registerOnParent(nodeId, registeredChildren.current, element);
      setIndex(newIndex);
    }
    return () => {
      if (unRegisterOnParent) unRegisterOnParent(nodeId);
    };
  }, [registerOnParent, unRegisterOnParent, setIndex, element, nodeId]);
  const registerDescendant = (0, _react.useCallback)((id, children, descendantElement) => {
    let newIndex = -1;
    if (registeredChildren.current) {
      const newItems = registeredChildren.current;
      const oldIndex = (0, _lodash.findIndex)(newItems, node => node.id === id);

      // new index based on DOM position
      newIndex = binaryFindElement(newItems, descendantElement);

      // If the descendant already exist, delete it and insert at the new index
      if (oldIndex >= 0) {
        newItems.splice(oldIndex, 1);
      }
      newItems.splice(newIndex, 0, {
        id,
        children,
        parentId: nodeId,
        index: newIndex,
        element: descendantElement
      });
      newItems.forEach((item, position) => {
        item.index = position;
      });
      registeredChildren.current = newItems;
      if (updateParent && hasRegisteredFlag.current) {
        updateParent(nodeId, registeredChildren.current, element);
      }
    }
    return newIndex;
  }, [registeredChildren.current, nodeId, updateParent, element]);
  const unRegisterDescendant = (0, _react.useCallback)(id => {
    if (registeredChildren.current) {
      registeredChildren.current = registeredChildren.current.filter(node => node.id !== id);
      registeredChildren.current.forEach((item, position) => {
        item.index = position;
      });
    }
  }, []);
  const updateDescendant = (0, _react.useCallback)((id, children, descendantElement) => {
    if (registeredChildren.current) {
      const currentIndex = (0, _lodash.findIndex)(registeredChildren.current, node => node.id === id);
      const newIndex = currentIndex < 0 ? registeredChildren.current.length : currentIndex;
      registeredChildren.current.splice(newIndex, 1, {
        id,
        children,
        parentId: nodeId,
        index: newIndex,
        element: descendantElement
      });
      if (updateParent && hasRegisteredFlag.current) {
        updateParent(nodeId, registeredChildren.current, element);
      }
    }
  }, [nodeId, updateParent, hasRegisteredFlag.current]);
  const updateCheckboxSelection = (0, _react.useCallback)((event, descendantId, checkedArray, uncheckedArray) => {
    if (registeredChildren.current) {
      const childNodesFiltered = registeredChildren.current.map(node => node.id).filter(id => id !== descendantId);
      const finalCheckedArray = [...checkedArray];
      const finalUnCheckedArray = [...uncheckedArray];
      childNodesFiltered.forEach(id => {
        if (hasCheckBoxSelected && hasCheckBoxSelected(id)) finalCheckedArray.push(id);else finalUnCheckedArray.push(id);
      });

      // decides whether current node should be in the checked array or unchecked array
      if (finalUnCheckedArray.length > 0) finalUnCheckedArray.push(nodeId);else finalCheckedArray.push(nodeId);
      if (updateCheckboxSelectionOnParent) updateCheckboxSelectionOnParent(event, nodeId, finalCheckedArray, finalUnCheckedArray);else if (handleCheckboxSelection) handleCheckboxSelection(event, finalCheckedArray, finalUnCheckedArray);
    }
  }, [nodeId, hasCheckBoxSelected, handleCheckboxSelection, updateCheckboxSelectionOnParent]);
  return {
    parentId,
    level,
    index,
    descendants,
    registerDescendant,
    unRegisterDescendant,
    updateDescendant,
    updateCheckboxSelection,
    updateCheckboxSelectionOnParent
  };
}
module.exports = exports.default;